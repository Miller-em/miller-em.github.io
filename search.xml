<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2021-四月学习计划</title>
      <link href="2021/04/15/Plans/2021_04/"/>
      <url>2021/04/15/Plans/2021_04/</url>
      
        <content type="html"><![CDATA[<p>最近感觉有种目标不够坚定的样子，经常感觉事情很多，又不知道要先干啥的样子。所以特定地设置一下四月份的目标，并且上传到博客，每次打开博客都能够一眼看到，也算明确一下目标吧！</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210415180054.gif" alt=""></p><h2 id="本月计划"><a href="#本月计划" class="headerlink" title="本月计划"></a>本月计划</h2><p><strong>必须完成部分：</strong></p><ul><li>[ ] 完成专业作业</li><li>[ ] 完成六级试卷4套，每套的听力精听</li><li>[ ] 完成OCR中的检测和识别</li><li>[ ] 计算机大赛的GUI美化问题</li><li>[ ] 飞卡智能车的AI部分实现和调优</li><li>[ ] 基于Pytorch的图片超分辨率实现</li></ul><p><strong>拟完成部分：</strong></p><ul><li>[ ] Android 学习 (控件)</li></ul><h2 id="12日-18日-计划"><a href="#12日-18日-计划" class="headerlink" title="12日-18日 计划"></a>12日-18日 计划</h2><ul><li>[ ] 完成信号与系统的作业和博客</li><li>[ ] 完成六级试卷一套</li><li>[ ] GUI美化  QSS</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo next主题解决无法显示Latex数学公式</title>
      <link href="2021/04/13/Blog/%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BALatex%E5%85%AC%E5%BC%8F/"/>
      <url>2021/04/13/Blog/%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BALatex%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>最近想写一遍关于傅里叶变换的文章，但是我发现<strong>Hexo</strong> <strong>Next</strong>主题下无法对<strong>Latex</strong>数学公式进行渲染，这个就让我显得很苦恼，因为数学公式实在是太多了，说明这类问题不用公式又不好理解，所以一定要解决这种问题。后来我通过百度发现了<strong>原因</strong>：</p><blockquote><p>Hexo 默认使用 <code>hexo-renderer-marked</code> 引擎渲染网页，该引擎会把一些特殊的 <code>markdown</code> 符号转换为相应的 <code>html</code> 标签，比如在 <code>markdown</code> 语法中，下划线<code>_</code>代表斜体，会被渲染引擎处理为<code>&lt;em&gt;</code>标签。</p><p>因为类 <code>Latex</code> 格式书写的数学公式下划线<code>_</code>表示下标，有特殊的含义，如果被强制转换为<code>&lt;em&gt;</code>标签，那么 <code>MathJax</code> 引擎在渲染数学公式的时候就会出错。</p><p>类似的语义冲突的符号还包括<code>*, &#123;, &#125;, \\</code>等。</p></blockquote><span id="more"></span><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>更换 Hexo 的 markdown 渲染引擎，hexo-renderer-kramed 引擎是在默认的渲染引擎 hexo-renderer-marked 的基础上修改了一些 bug ，两者比较接近，也比较轻量级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><p>执行上面的命令即可，先卸载原来的渲染引擎，再安装新的。<br>然后，跟换引擎后行间公式可以正确渲染了，但是这样还没有完全解决问题，行内公式的渲染还是有问题，因为 <code>hexo-renderer-kramed</code> 引擎也有语义冲突的问题。接下来到博客根目录下，找到<code>node_modules\kramed\lib\rules\inline.js</code>，把第11行的 escape 变量的值做相应的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;escape: &#x2F;^\\([\\&#96;*&#123;&#125;\[\]()#$+\-.!_&gt;])&#x2F;,</span><br><span class="line">escape: &#x2F;^\\([&#96;*\[\]()#$+\-.!_&gt;])&#x2F;,</span><br></pre></td></tr></table></figure><p>这一步是在原基础上取消了对<code>\,&#123;,&#125;</code>的转义(escape)。<br>同时把第20行的em变量也要做相应的修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;em: &#x2F;^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)&#x2F;,</span><br><span class="line">em: &#x2F;^\*((?:\*\*|[\s\S])+?)\*(?!\*)&#x2F;,</span><br></pre></td></tr></table></figure><p>重新启动hexo（先clean再generate）,问题完美解决。哦，如果不幸还没解决的话，看看是不是还需要在使用的主题中配置<strong>mathjax</strong>开关。</p><h3 id="在-Next-主题中开启-MathJax-开关"><a href="#在-Next-主题中开启-MathJax-开关" class="headerlink" title="在 Next 主题中开启 MathJax 开关"></a>在 Next 主题中开启 MathJax 开关</h3><p>如果使用了主题，别忘了在主题（Theme）中开启 MathJax 开关，下面以 next 主题为例，介绍下如何打开 MathJax 开关。</p><p>进入到主题目录，找到 _config.yml 配置问题，把 math 默认的 false 修改为true，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Math Equations Render Support</span><br><span class="line">math:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Default(true) will load mathjax&#x2F;katex script on demand</span><br><span class="line">  # That is it only render those page who has &#39;mathjax: true&#39; in Front Matter.</span><br><span class="line">  # If you set it to false, it will load mathjax&#x2F;katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line"></span><br><span class="line">  engine: mathjax</span><br><span class="line">  #engine: katex</span><br></pre></td></tr></table></figure><p>还需要在文章的Front-matter里打开mathjax开关，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: index.html</span><br><span class="line">date: 2018-07-05 12:01:30</span><br><span class="line">tags:</span><br><span class="line">mathjax: true</span><br><span class="line">--</span><br></pre></td></tr></table></figure><p>之所以<strong>要在文章头里设置开关</strong>，是因为考虑只有在用到公式的页面才加载 Mathjax，这样不需要渲染数学公式的页面的访问速度就不会受到影响了。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号与系统——傅里叶级数和傅里叶变换基本要点</title>
      <link href="2021/04/12/signal_and_system/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
      <url>2021/04/12/signal_and_system/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>最近学到了信号与系统最难的部分，也是十分重要的一个部分，不管在哪个领域，学好<strong>信号与系统</strong>都是十分有必要且有帮助的。同时在信号与系统这门课里面最核心的部分之一就是<strong>傅里叶变换</strong>。傅里叶变换是傅里叶一项伟大的成就。到目前，许多领域都还在使用傅里叶变换对信号进行处理，傅里叶给出了信号在<strong>时域</strong>和<strong>频域</strong>进行变换。为后面用到的信号处理技术，提供了基础。下面记录了一些对于傅里叶级数和傅里叶变换的基本公式和常用的计算方法，方便以后复习使用。</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210416135516.jpeg" alt="" style="zoom:25%;" /></p><span id="more"></span><h2 id="正交函数集的概念"><a href="#正交函数集的概念" class="headerlink" title="正交函数集的概念"></a>正交函数集的概念</h2><p>为了方便对信号进行分析，常常将复杂的信号分解为基本信号的线性组合。目前的信号基本上都是在正交函数集的基础上面进行分解。</p><blockquote><p>对于函数集 $\left\{f_{n}(t), n=1,2, \cdots\right\}$，如果</p><script type="math/tex; mode=display">\int_{A_{1}}^{A_{2}} f_{n_{1}}(t) f_{n_{2}}^{*}(t) \mathrm{d} t=0, n_{1}, n_{2}=1,2,3, \cdots</script><p>且 $n_{1} \neq n_{2}$，则称此函数集称为$\left[\begin{array}{ll}A_{1} , A_{2}\end{array}\right]$上的<strong>正交函数集</strong>。</p></blockquote><p> 在<strong>实变函数域</strong>，常见的有三角形式的正交函数集：</p><script type="math/tex; mode=display">\left\{1, \sin n \omega_{0} t, \cos n \omega_{0} t, n=1,2, \cdots\right\}</script><p>在<strong>复变函数域</strong>，常见的有复指数形式正交函数集：</p><script type="math/tex; mode=display">\left\{\mathrm{e}^{\mathrm{j} n \omega_{0}{t}}, n=\pm 1, \pm 2, \cdots\right\}</script><p>对于三角正交函数集或复指数正交函数集，在正交区间$\left(t_{0}, t_{0}+T\right)$内，以下等式成立：</p><script type="math/tex; mode=display">\int_{t_{0}}^{t_{0}+T} \cos n \omega_{0} t \cdot \cos m \omega_{0} t \mathrm{~d} t=\left\{\begin{array}{ll}0 & (m \neq n) \\\frac{T}{2} & (m=n)\end{array}\right.</script><script type="math/tex; mode=display">\int_{t_{0}}^{t_{0}+T} \sin n \omega_{0} t \cdot \sin m \omega_{0} t \mathrm{~d} t=\left\{\begin{array}{ll}0 & (m \neq n) \\\frac{T}{2} & (m=n)\end{array}\right.</script><script type="math/tex; mode=display">\int_{t_{0}}^{t_{0}+T} \cos n \omega_{0} t \cdot \sin m \omega_{0} t d t=0</script><script type="math/tex; mode=display">\int_{t_{0}}^{t_{0}+T} \mathrm{e}^{\mathrm{j} n \omega_{0} t} \cdot\left(\mathrm{e}^{\mathrm{j} m \omega_{0} t}\right)^{*} \mathrm{~d} t=\left\{\begin{array}{ll}0 & (m \neq n) \\T & (m=n)\end{array}\right.</script><p>式中 $T=2 \pi / \omega_{0}$ 为函数 $\sin \omega_{0} t, \cos \omega_{0} t$ 或 $\mathrm{e}^{\mathrm{j} \omega_{0} t}$ 的周期。</p><blockquote><p>注意：</p><p>在三角正交函数集中，当 $n=0$ 时，$\cos 0=1, \sin 0=0$，而 0 不应该计在此正交函数集中，故三角正交函数集可具体写为：</p><script type="math/tex; mode=display">\left\{1, \sin \omega_{0} t, \sin 2 \omega_{0} t, \cdots, \cos \omega_{0} t, \cos 2 \omega_{0} t, \cdots\right\}</script></blockquote><h2 id="三角形式傅里叶级数"><a href="#三角形式傅里叶级数" class="headerlink" title="三角形式傅里叶级数"></a>三角形式傅里叶级数</h2><p>将任意一个周期信号在三角函数或复指数函数组成的完备正交函数集分解得到的级数,统称为傅里叶级数(Fourier Series, FS)。它们具有如下一些显著优点：</p><ol><li>三角函数和复指数函数是自然界中最常见,最基本的函数</li><li><strong>三角函数和复指数函数是简谐函数,用它们表示时间信号,自然地建立起了时间和频率这两个基本物理量间的联系</strong></li><li>简谐信号较其他信号更容易产生和处理</li><li>三角信号或复指数信号通过线性时不变系统后,仍为三角函数和复指数函数,其频率不变,只是幅度和相位产生变化,同时,线性时不变系统对三角函数或复指数函数的响应求解非常方便</li><li>许多系统(例如滤波器、信息传输系统等)的特性主要由其<strong>频域特性</strong>来描述,因此常常需要关心的并不是这些系统的冲激响应，而是其冲激响应所对应的频率特性</li><li><strong>时域中的卷积运算在频域中会转化为乘积运算</strong>,从而找到了计算卷和的-种新方永时域中难于实现的卷积求解便于实现。</li></ol><h3 id="周期信号的傅里叶级数"><a href="#周期信号的傅里叶级数" class="headerlink" title="周期信号的傅里叶级数"></a>周期信号的傅里叶级数</h3><p>如果一个信号是周期信号，则有：</p><script type="math/tex; mode=display">{f(t)=\tilde{f}(t+m T)} \quad m=0, \pm 1, \pm 2, \cdots</script><p>傅里叶提出：任何的周期信号都可以分解为正弦和余弦分量的叠加。所以，周期信号可以展开为如下形式：</p><script type="math/tex; mode=display">\tilde{f}(t)=\frac{a_{0}}{2}+\sum_{n=1}^{\infty} a_{n} \cos n \omega_{0} t+\sum_{n=1}^{\infty} b_{n} \sin n \omega_{0} t</script><p>其实就是把函数 $\tilde{f}(t)$，展开成为正交函数集 $\left\{\sin n \omega_{0} t, \cos n \omega_{0} t, n=0,1,2, \cdots\right\}$ 中函数的线性叠加。其中 <strong>$\omega_{0}$</strong> 称为<strong>基波角频率</strong>：</p><script type="math/tex; mode=display">\omega_{0}=\frac{2 \pi}{T}</script><p>对于上面的展开式中，其中的系数我们可以通过计算得到：</p><script type="math/tex; mode=display">a_{0}=\frac{2}{T} \int_{t_{0}}^{t_{0}+T} \tilde{f}(t) \mathrm{d} t</script><script type="math/tex; mode=display">a_{n}=\frac{2}{T} \int_{t_{0}}^{t_{0}+T} \tilde{f}(t) \cos n \omega_{0} t \mathrm{~d} t</script><script type="math/tex; mode=display">b_{n}=\frac{2}{T} \int_{t_{0}}^{t_{0}+T} \tilde{f}(t) \sin n \omega_{0} t \mathrm{~d} t</script><p>其中，$a_{0}$ 称为直流系数， $a_{n}$ 称为余弦分量系数 ，$b_{n}$ 称为正弦分量系数。</p><p>我们还可以把同频项合并，可以得到：</p><script type="math/tex; mode=display">\tilde{f}(t)=\frac{a_{0}}{2}+\sum_{n=1}^{\infty} a_{n} \cos n \omega_{0} t+\sum_{n=1}^{\infty} b_{n} \sin n \omega_{0} t=A_{0}+\sum_{n=1}^{\infty} A_{n} {\cos \left(n \omega_{0} t+\varphi_{n}\right)}</script><p>其中：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}A_{0}=\frac{a_{0}}{2} \\A_{n}=\sqrt{a_{n}^{2}+b_{n}^{2}} \\\varphi_{n}=-\arctan \left(\frac{b_{n}}{a_{n}}\right)\end{array}\right.</script><script type="math/tex; mode=display">\left\{\begin{array}{l}a_{n}=A_{n} \cos \varphi_{n} \\b_{n}=-A_{n} \sin \varphi_{n}\end{array}\right.</script><blockquote><p>需要注意的是,并非所有的周期信号都可以展开成三角形式傅里叶级数。信号能进行三角形式傅里叶级数展开的条件为:周期信号 $\tilde{f}(t)$ 在一个周期内 $\left[-\frac{T}{2}, \frac{T}{2}\right)$ 满足以下两个条件,称为<strong>狄里赫利(Dirichlet)</strong>条件。</p><ol><li><p>处处连续或至多有有限个第一类间断点</p></li><li><p>至多有有限多个极值点。</p></li></ol></blockquote><h2 id="指数形式的傅里叶级数"><a href="#指数形式的傅里叶级数" class="headerlink" title="指数形式的傅里叶级数"></a>指数形式的傅里叶级数</h2><p>周期信号除了可以展开为三角形式的傅里叶级数外，在满足狄里赫利条件的情况下，还可以分解为如下形式：</p><script type="math/tex; mode=display">\tilde{f}(t)=\sum_{n=-\infty}^{\infty} F_{n} \mathrm{e}^{\mathrm{j} n \omega_{0} t}</script><p>其中 <strong>$\omega_{0}$</strong> 仍然称为<strong>基波角频率</strong>。</p><h3 id="指数形式傅里叶级数的系数确定"><a href="#指数形式傅里叶级数的系数确定" class="headerlink" title="指数形式傅里叶级数的系数确定"></a>指数形式傅里叶级数的系数确定</h3><p>周期信号的傅里叶级数对可以完整地表示成：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\tilde{f}(t)=\sum_{n=-\infty}^{\infty} F_{n} \mathrm{e}^{\mathrm{jn} \omega_{0} t} \\ F_{n}=\frac{1}{T} \int_{0}^{T} \tilde{f}(t) \mathrm{e}^{-\mathrm{j} n \omega_{0} t} \mathrm{~d} t \end{array}\right.</script><p>$F_{n}$ 通常称为 $\tilde{f}(t)$ 的复指数形式<strong>傅里叶级数</strong>或<strong>频谱级数</strong>。</p><h2 id="连续时间信号的傅里叶变换"><a href="#连续时间信号的傅里叶变换" class="headerlink" title="连续时间信号的傅里叶变换"></a>连续时间信号的傅里叶变换</h2><p>除周期信号外，自然界及各种工程技术领域中还广泛地存在许多非周期信号。非周期信号，就是周期信号的周期趋近于无穷大时，周期信号转化为非周期信号，但其对于频谱的谱线间隙 $\omega_{0} = \frac{2 \pi}{T}$ 趋近于无穷小，即离散频谱转变成了连续频谱。所以研究非周期信号的连续时间信号的傅里叶变换也是非常有必要的。</p><p>为此给出傅里叶变换对，即傅里叶正变换和逆变换：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}F(j \omega)=\int_{-\infty}^{\infty} f(t) \mathrm{e}^{-\mathrm{j} \omega t} \mathrm{~d} t\\ f(t)=\frac{1}{2 \pi} \int_{-\infty}^{\infty} F(j \omega) \mathrm{e}^{\mathrm{j} \omega t} \mathrm{~d} t \end{array}\right.</script><p>$F(j\omega)$ 称为 $f(t)$ 的<strong>频率密度函数</strong>或简称<strong>频谱函数</strong></p><p>根据频谱函数的定义及欧拉公式可得：</p><script type="math/tex; mode=display">F(j \omega) = \int_{-\infty}^{\infty}f(t)\mathrm{e}^{-\mathrm{j} \omega t} \mathrm{~d}t \\= \int_{-\infty}^{\infty} f(t)cos\omega t \mathrm{~d}t - j\int_{-\infty}^{\infty} f(t)sin\omega t \mathrm{~d}t \\=\mathrm{~R}(\omega) +j\mathrm{X}(\omega) \\= |F(j \omega)| \mathrm{e}^{j \varphi(\omega)}</script><p>由上面的式子可以得到以下关系：</p><script type="math/tex; mode=display">\left.\begin{array}{l}|F(\mathrm{j} \omega)|=\sqrt{R^{2}(\omega)+X^{2}(\omega)} \\\varphi(\omega)=\arctan \frac{X(\omega)}{R(\omega)} \\R(\omega)=|F(\mathrm{j} \omega)| \cos \varphi(\omega) \\X(\omega)=|F(\mathrm{j} \omega)| \sin \varphi(\omega)\end{array}\right\} \quad \begin{array}{l}\end{array}</script><p>$|F(\mathrm{j} \omega)|$ 关于 $ \omega $ 的 图像称为 <strong>幅度谱</strong>， $\varphi(\omega)$ 关于 $ \omega $ 的 图像称为 <strong>相位谱</strong></p><h3 id="常用的傅里叶变换对"><a href="#常用的傅里叶变换对" class="headerlink" title="常用的傅里叶变换对"></a>常用的傅里叶变换对</h3><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th>$f(t)$</th><th>$F(\mathrm{j} \omega)$</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td>$g_{\tau}(t)$</td><td>$\tau Sa(\frac{\omega \tau}{2})$</td></tr><tr><td style="text-align:left">2</td><td>$\tau Sa(\frac{\omega t}{2})$</td><td>$2 \pi g_{\tau}(\omega)$</td></tr><tr><td style="text-align:left">3</td><td>$\mathrm{e}^{-\alpha t}u(t), \alpha &gt; 0$</td><td>$\frac{1}{a+j \omega}$</td></tr><tr><td style="text-align:left">4</td><td>$t \mathrm{e}^{-\alpha t}u(t), \alpha &gt; 0$</td><td>$\frac{1}{(a+j \omega)^2}$</td></tr><tr><td style="text-align:left">5</td><td>$\mathrm{e}^{-\alpha t}, \alpha &gt; 0 (由于博客转义问题，t为绝对值t)$</td><td>$\frac{2 \alpha}{\alpha^2+\omega^2}$</td></tr><tr><td style="text-align:left">6</td><td>$\delta(t)$</td><td>1</td></tr><tr><td style="text-align:left">7</td><td>1</td><td>$2\pi\delta(\omega)$</td></tr><tr><td style="text-align:left">8</td><td>$\delta(t - t_{0})$</td><td>$\mathrm{e}^{-j \omega t_{0}}$</td></tr><tr><td style="text-align:left">9</td><td>$cos(\omega t_0)$</td><td>$\pi[\delta(\omega+\omega_{0})+\delta(\omega-\omega_{0})]$</td></tr><tr><td style="text-align:left">10</td><td>$sin(\omega t_0)$</td><td>$j\pi[\delta(\omega+\omega_{0})-\delta(\omega-\omega_{0})]$</td></tr><tr><td style="text-align:left">11</td><td>$u(t)$</td><td>$\pi\delta(\omega)+\frac{1}{j\omega}$</td></tr><tr><td style="text-align:left">12</td><td>$sgn(t)$</td><td>$\frac{2}{j\omega},F(0) =0$</td></tr><tr><td style="text-align:left">13</td><td>$\frac1{\pi t}$</td><td>$-jsgn(t)$</td></tr><tr><td style="text-align:left">14</td><td>$\delta_{T}(t)$</td><td>$\omega_0\delta_{\omega_0}(\omega)$</td></tr><tr><td style="text-align:left">15</td><td>$\sum_{n=-\infty}^{\infty}F_{n}\mathrm{e}^{jn\omega_0 t}$</td><td>$2\pi\sum_{n=-\infty}^{\infty}F_n\delta(\omega-n\omega_0)$</td></tr><tr><td style="text-align:left">16</td><td>$\frac{t^{n-1}}{(n-1)!}\mathrm{e}^{-\alpha t}u(t), \alpha&gt;0$</td><td>$\frac{1}{(\alpha+j\omega)^n}$</td></tr></tbody></table></div><h2 id="傅里叶变换的性质与应用"><a href="#傅里叶变换的性质与应用" class="headerlink" title="傅里叶变换的性质与应用"></a>傅里叶变换的性质与应用</h2><p>傅里叶变换建立起了信号时域与频域间的联系。下面介绍傅里叶变换的性质，研究信号在时域中进行运算或变化时，在频域引起的效应。</p><h3 id="傅里叶变换的性质"><a href="#傅里叶变换的性质" class="headerlink" title="傅里叶变换的性质"></a>傅里叶变换的性质</h3><div class="table-container"><table><thead><tr><th>性质名称</th><th>时域</th><th>频域</th></tr></thead><tbody><tr><td>线性</td><td>$a_1f_1(t)+a_2f_2(t)$</td><td>$a_{1} F_{1}(j \omega)+a_{2} F_{2}(j \omega)$</td></tr><tr><td>时移</td><td>$f(t±t_0)$</td><td>$F(j \omega) \mathrm{e}^{±j \omega t_0}$</td></tr><tr><td>频移</td><td>$f(t)\mathrm{e}^{±j \omega_0t}$</td><td>$F\left[\mathrm{j}\left(\omega \mp \omega_{0}\right)\right]$</td></tr><tr><td>调制</td><td>$f(t)cosw_0t$</td><td>$\frac{1}{2}\left[F\left(j\left(\omega-\omega_{0}\right)\right)+F\left(j\left(\omega+\omega_{0}\right)\right)\right]$</td></tr><tr><td>调制</td><td>$f(t)sin\omega_0t$</td><td>$\frac{1}{2 \mathrm{j}}\left[F\left(\mathrm{j}\left(\omega-\omega_{0}\right)\right)-F\left(\mathrm{j}\left(\omega+\omega_{0}\right)\right)\right]$</td></tr><tr><td>尺度变换</td><td>$f(at)$</td><td>$\frac{1}{\mathrm{l}a\mathrm{l}} F\left(j \frac{\omega}{a}\right)$</td></tr><tr><td>对称性</td><td>$F(jt)$</td><td>$2 \pi f(-\omega)$</td></tr><tr><td>时域卷积</td><td>$f_1(t)*f_2(t)$</td><td>$F_{1}(j \omega) \cdot F_{2}(j \omega)$</td></tr><tr><td>频域卷积</td><td>$f_1(t) \cdot f_2t()$</td><td>$\frac{1}{2 \pi}\left[F_{1}(j \omega) * F_{2}(j \omega)\right]$</td></tr><tr><td>时域微分</td><td>$\frac{\mathrm{~d}^nf(t)}{\mathrm{~d}t^n}$</td><td>$(j \omega)^{n} F(j \omega)$</td></tr><tr><td>频域微分</td><td>$(-jt)^nf(t)$</td><td>$\frac{\mathrm{d}^{n} F(j \omega)}{\mathrm{d} \omega^{*}}$</td></tr><tr><td>时域积分</td><td>$\int_{-\infty}^{t} f(x) \mathrm{~d}t$</td><td>$\frac{F(j \omega)}{j \omega}+\pi F(0) \delta(\omega)$</td></tr><tr><td>频域积分</td><td><script type="math/tex">\pi f(0) \delta(t)+\frac{f(t)}{-j t}</script></td><td>$\int_{-\infty}^{\infty} F(j \eta) d \eta$</td></tr><tr><td>帕塞瓦尔定理</td><td>$\int_{-\infty}^{\infty} f^{2}(t) \mathrm{d} t$</td><td>$\frac{1}{2 \pi} \int_{-\infty}^{\infty}F(j \omega)^2\mathrm{~d}t,(其中F(j \omega)^2是F(j \omega)的绝对值的平方，也是博客转义问题)$</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 信号与系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号与系统 </tag>
            
            <tag> 傅里叶变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICDAR2019-LSVT 数据集预处理</title>
      <link href="2021/04/09/deep_learning/icdar2019/"/>
      <url>2021/04/09/deep_learning/icdar2019/</url>
      
        <content type="html"><![CDATA[<p>对于OCR要实现识别中文字符，数据集的选择是非常重要的，一定要是中文数据集。这里选择使用ICDAR2019-LSVT。因为给定的数据集，不符合<strong>PaddleOCR</strong>的train.py能够识别的格式，同时官方没有提供测试集的label，所以我们要将其进行调整：从官方给的训练集重新划分训练集和测试集，同时为其生成对应的label文件。</p><h2 id="数据集的选择"><a href="#数据集的选择" class="headerlink" title="数据集的选择"></a>数据集的选择</h2><p><strong>数据简介</strong>： ICDAR2019-LSVT共包括45w中文街景图像，包含5w（2w测试+3w训练）全标注数据（文本坐标+文本内容），40w弱标注数据（仅文本内容），如下图所示：</p> <span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210409153119.png" alt="image-20210409153118954"></p><p>这里考虑数据集太大的原因，所以只选择了全标注的数据集作为训练集和测试集。一共3w张图片。所以这里就下载了三个文件：<code>train_full_images_0.tar.gz</code>，<code>train_full_images_0.tar.gz</code>，<code>train_full_labels.json</code></p><p>数据集下载地址：<a href="https://ai.baidu.com/broad/download?dataset=lsvt">https://ai.baidu.com/broad/download?dataset=lsvt</a></p><h2 id="划分训练集和测试集"><a href="#划分训练集和测试集" class="headerlink" title="划分训练集和测试集"></a>划分训练集和测试集</h2><p>我先将下载的两个数据集合成了一个full_images，里面一共有3w张图片。现在需要做的是分成训练集和测试集比例为8：2，分别放在train_images, test_images文件夹下面。</p><p>直接贴上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span>(<span class="params">args, images_names</span>):</span></span><br><span class="line">    origin_images_path = args.images_dir_path</span><br><span class="line">    save_train_dir_path = args.train_dir_path</span><br><span class="line">    save_test_dir_path = args.test_dir_path</span><br><span class="line"></span><br><span class="line">    rate = <span class="number">0.8</span></span><br><span class="line">    train_images = images_names[:<span class="built_in">int</span>(rate*<span class="built_in">len</span>(images_names))]</span><br><span class="line">    test_images = images_names[<span class="built_in">int</span>(rate*<span class="built_in">len</span>(images_names)):]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> train_image <span class="keyword">in</span> train_images:</span><br><span class="line">        origin_image_path = os.path.join(origin_images_path, train_image)</span><br><span class="line">        save_image_path = os.path.join(save_train_dir_path, train_image)</span><br><span class="line">        shutil.copy(origin_image_path, save_image_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> test_image <span class="keyword">in</span> test_images:</span><br><span class="line">        origin_image_path = os.path.join(origin_images_path, test_image)</span><br><span class="line">        save_image_path = os.path.join(save_test_dir_path, test_image)</span><br><span class="line">        shutil.copy(origin_image_path, save_image_path)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_images</span>(<span class="params">args</span>):</span></span><br><span class="line">    origin_images_path = args.images_dir_path</span><br><span class="line">    <span class="keyword">for</span> dirpath, dirnames, filesnames <span class="keyword">in</span> os.walk(origin_images_path):</span><br><span class="line">        print(<span class="string">&quot;原数据集的图片数量为：&quot;</span>, <span class="built_in">len</span>(filesnames))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filesnames </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--images_dir_path&#x27;</span>,</span><br><span class="line">                         <span class="built_in">type</span>=<span class="built_in">str</span>, </span><br><span class="line">                         default=<span class="string">&#x27;./train_data/ICDAR2019-LSVT/full_images/&#x27;</span>,</span><br><span class="line">                         <span class="built_in">help</span>=<span class="string">&#x27;原数据集的路径&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--train_dir_path&#x27;</span>,</span><br><span class="line">                         <span class="built_in">type</span>=<span class="built_in">str</span>, </span><br><span class="line">                         default=<span class="string">&#x27;./train_data/ICDAR2019-LSVT/train_images/&#x27;</span>,</span><br><span class="line">                         <span class="built_in">help</span>=<span class="string">&#x27;保存训练集的路径&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--test_dir_path&#x27;</span>,</span><br><span class="line">                         <span class="built_in">type</span>=<span class="built_in">str</span>, </span><br><span class="line">                         default=<span class="string">&#x27;./train_data/ICDAR2019-LSVT/test_images/&#x27;</span>,</span><br><span class="line">                         <span class="built_in">help</span>=<span class="string">&#x27;保存测试集的路径&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    images_names = load_images(args)</span><br><span class="line">    split(args, images_names)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="生成对应的label"><a href="#生成对应的label" class="headerlink" title="生成对应的label"></a>生成对应的label</h2><p>训练集和测试集分好了，最后需要是生成训练集和测试集的label文件，这样才能够训练。</p><p>直接贴上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    json_path = <span class="string">&#x27;./train_data/ICDAR2019-LSVT/full_labels.json&#x27;</span></span><br><span class="line">    test_imgs_path = <span class="string">&#x27;./train_data/ICDAR2019-LSVT/test_images/&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(json_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = json.load(f)</span><br><span class="line">    train_imgs_path = <span class="string">&#x27;./train_data/ICDAR2019-LSVT/train_images/&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./train_data/ICDAR2019-LSVT/train_label.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fw:</span><br><span class="line">        <span class="keyword">for</span> dirpath, dirnames, images_names <span class="keyword">in</span> os.walk(train_imgs_path):</span><br><span class="line">            imgs_num = <span class="built_in">len</span>(images_names)</span><br><span class="line">            print(<span class="string">&quot;该训练集的数量为：&quot;</span>, imgs_num)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> images_name <span class="keyword">in</span> images_names:</span><br><span class="line">            image_path = <span class="string">&#x27;train_images/&#x27;</span> + images_name</span><br><span class="line">            fname, fename = os.path.splitext(images_name)</span><br><span class="line">            image_label = image_path + <span class="string">&#x27;\t&#x27;</span> + json.dumps(data[fname]) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            fw.write(image_label)</span><br><span class="line">        fw.close()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./train_data/ICDAR2019-LSVT/test_label.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fb:</span><br><span class="line">        <span class="keyword">for</span> dirpath, dirnames, images_names <span class="keyword">in</span> os.walk(test_imgs_path):</span><br><span class="line">            imgs_num = <span class="built_in">len</span>(images_names)</span><br><span class="line">            print(<span class="string">&quot;该测试集的数量为：&quot;</span>, imgs_num)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> images_name <span class="keyword">in</span> images_names:</span><br><span class="line">            image_path = <span class="string">&#x27;test_images/&#x27;</span> + images_name</span><br><span class="line">            fname, fename = os.path.splitext(images_name)</span><br><span class="line">            image_label = image_path + <span class="string">&#x27;\t&#x27;</span> + json.dumps(data[fname]) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            fb.write(image_label)</span><br><span class="line">        fb.close()</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OCR </tag>
            
            <tag> paddle </tag>
            
            <tag> 数据集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bad owner or permissions on .ssh/config Windows 10</title>
      <link href="2021/04/08/questions/ssh/"/>
      <url>2021/04/08/questions/ssh/</url>
      
        <content type="html"><![CDATA[<p>最近想尝试在vscode中用remote ssh插件尝试远程开发，可是几次没有成功，在cmd里面输入<code>ssh xx@ip</code>，提示了 <code>Bad owner or permissions on .ssh/config</code> 这个报错，就是如图中的问题:</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210408193114.png" alt="image-20210408193114481"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>找到.ssh文件夹。它通常位于C:\Users\，例如C:\Users\xxxx。</li><li>右键单击.ssh文件夹，然后单击“属性”。</li><li>找到并点击“安全”标签。<span id="more"></span></li><li>然后单击“高级”。</li><li>单击“禁用继承”，单击“确定”。</li><li>将出现警告弹出窗口。单击“从此对象中删除所有继承的权限”。</li><li>你会注意到所有用户都将被删除。让我们添加所有者。在同一窗口中，单击“编辑”按钮。</li><li>接下来，单击“添加”以显示“选择用户或组”窗口。</li><li>单击“高级”，然后单击“立即查找”按钮。应显示用户结果列表。</li><li>选择您的用户帐户。</li><li>然后单击“确定”（大约三次）以关闭所有窗口。</li></ol><p>完成所有操作后，再次关闭并打开cmd应用程序并尝试连接到远程SSH主机。现在这个问题应该解决了，同时在vscode也就可以成功连接了。</p>]]></content>
      
      
      <categories>
          
          <category> 远程开发操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 常用控件方法介绍-Android入门(一)</title>
      <link href="2021/03/27/Android/controls/"/>
      <url>2021/03/27/Android/controls/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>任何<strong>GUI</strong>的设计，入门的话，一定是控件的使用。前面学过PyQt ，有一些基本的GUI的设计思想。所以对于安卓部分的话，控件还是很容易上手的。主要是需要熟悉一下Android Studio的使用方法，以及生成的工程结构。在Android Studio里面，我们想要使用一个控件的话，是直接对XML文件进行编写，所以对于基本的XML文件的书写，要熟悉XML的语法。下面我将会介绍常用的几个Android的控件。</p><p>使用控件我们是在<code>activity_main.xml</code>里面进行编辑，这个文件是在Project结构下<code>app/src/main/res/layout/activity_main.xml</code><br> <span id="more"></span></p><h2 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h2><p>介绍控件，首先介绍方法：</p><blockquote><p>基础属性：</p><ul><li>layout_width：组件的宽度</li><li>layout_height：组件的高度</li><li>id：为TextView设置一个id号</li><li>text：设置显示的文本内容</li><li>textColor：设置字体颜色</li><li>textSize：字体大小，单位一般是用sp</li><li>textStyle：设置字体风格，三个可选值：normal， bold，italic</li><li>background：控件的背景颜色，可以理解为填充整个控件的颜色，可以是图片</li><li>gravity：设置控件中内容的对齐方向，TextView中是文件，ImageView中是图片</li></ul><p>带阴影的TextView:</p><ul><li>android:shadowColor：设置阴影颜色，需要与shadowRadius一起使用</li><li>android:shadowRadius：设置阴影的模糊程度，设为0.1就变成字体颜色了，建议使用3.0</li><li>android:shadowDx：设置阴影在水平方向的偏移，就是水平方向阴影开始的横坐标位置</li><li>android:shadowDy：设置阴影在竖直方向的偏移，就是竖直方向阴影开始的纵坐标位置</li></ul></blockquote><p>使用效果实例：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210331194049.png" alt="image-20210331194048904"></p><h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><p>按键也是控件里面重要性占比最大的，这里就介绍一下Button控件该如何使用。首先还是介绍一下常用的几个方法：</p><p><strong>StateListDrawable</strong></p><p>StateListDrawable是Drawable资源的一种，可以根据不同的状态，设置不同的图片效果，关键节点&lt; selector &gt;，我们只需要将Button的 background属性设置为该drawable资源即可轻松实现，按下按钮时不同的按钮颜色或背景。</p><blockquote><ul><li>drawable：引用的Drawable位图</li><li>state_focused：是否获取焦点</li><li>state_pressed：控件是否被按下</li><li>state_enabled：控件是否可用</li><li>state_selected：控件是否被选择，针对有滚轮的情况</li><li>state_checked：控件是否被勾选</li><li>state_checkable：控件可否被勾选，eg:checkbox</li></ul></blockquote><p><strong>Button事件处理</strong></p><ul><li>点击事件</li><li>长按事件</li><li>触摸事件</li></ul><p>使用效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210331215525.png" alt="image-20210331215525650"></p><p>其中的<code>backgroud</code>和<code>backgroundTink</code> 里面的值，分别是在drawable文件夹下面创建的selector，和在color文件夹下面的selector。</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210331220029.png" alt="image-20210331220029489"></p><p>对于按键事件的触发，是在<code>MainActivity.java</code>里面添加，下面就是MainActivity的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mybutton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;Miller&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        View btn = findViewById(R.id.btn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//点击事件</span></span><br><span class="line">        btn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;onClick: &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//长按事件</span></span><br><span class="line">        btn.setOnLongClickListener(<span class="keyword">new</span> View.OnLongClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onLongClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;onLongClick: &quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触摸事件</span></span><br><span class="line">        btn.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;onTouch: &quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h2><p>这是一个文本的输入框，也是一个必须掌握的控件。先介绍常用的方法：</p><ul><li>android:hint   输入提示</li><li>android:textColorHint  输入提示文字的颜色</li><li>android:inputType  输入类型</li><li>android:drawableXxxx  在输入框的指定方向添加图片</li><li>android:drawablePaddling  设置图片与输入内容的间距</li><li>android:paddingXxxx  设置内容与边框的间距</li><li>android:background  背景色</li></ul><p>在Android Studio里面的使用的如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210401163542.png" alt="image-20210401163542564"></p><h2 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h2><p>这是一个显示图片的控件，有时候我们需要用图片填充我们的界面，所以还是要学习一下的，他的常用方法如下：</p><ul><li>android:src 设置图片资源                                     </li><li>android:scaleType 设置图片缩放类型</li><li>android:maxHeight 最大高度</li><li>android:maxWidth 最大宽度</li><li>android:adjustViewBounds 调整View的界限</li></ul><p>值得注意的是还有图片的缩放类型：</p><ul><li>fitStart  保持宽高比缩放图片，直到较长的边与Image的边长相等，缩放完成后将图片放在ImageView的左上角</li><li>fitEnd  同上，缩放后放于右下角</li></ul><ol><li>fitXY  对图像的横纵方向进行独立缩放，使得该图片完全适应lmageView，但是图片的宽高比可能会发生改变</li><li>center 保持原图的大小，显示在lmageView的中心。当原图的size大于lmageVview的size，超过部分裁剪处理。</li><li>centerCrop 保持宽高比缩放图片，直到完全覆盖lmageView，可能会出现图片的显示不完全</li><li>centerInside  保持宽高比缩放图片，直到ImageView能够完全地显示图片</li><li>matrix 不改变原图的大小，从lmageView的左上角开始绘制原图，原图超过lmageVview的部分作裁剪处理</li></ol><p>实验示例：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210401194646.png" alt="image-20210401194646607"></p><h2 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h2><p>这是一个进度条的控件，常用的方法如下：</p><ul><li><p>android:max: 进度条的最大值</p></li><li><p>android:progress: 进度条已完成进度值</p></li><li><p>android:indeterminate: 如果设置成true,则进度条不精确显示进度</p></li><li><p>style=”?android:attr/progressBarStyleHorizontal” 水平进度条</p></li></ul><p>实践示例：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210401203614.png" alt="image-20210401203614181"></p><p>效果：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210401203650.png" alt="image-20210401203650421" style="zoom:25%;" /></p><h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h2><p>这里介绍一下，通知的使用。要想使用通知组件，需要创建两个对象，一个是NotificationManager，一个是Notification。</p><ul><li>创建一个NotificationManager<br>NotificationManager类是一个<strong>通知管理器类</strong>， 这个对象是由系统维护的服务，是以单例模式的方式获得，所以一般并不直接实例化这个对象。在Activity中， 可以使用<code>Activity.getSystemService(String)</code>方法获取<strong>NotificationManager</strong>对象，Activity.getSystemService(String)方法可以通过Android系统级服务的句柄，返回对应的对象。在这里需要返回NotificationManager,所以直接传递Context.NOTIFICATION SERVICE即可 。</li><li>使用<strong>Bilder</strong>构造器来创建Notification对象<br>使用NotificationCompat类的Builder构造器来创建Notification对象，可以保证程序在所有的版本上都能正常工作。Android8.0新增了通知渠道这个概念，如果没有设置，则通知无法在Android8.0的机器上显示</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三天通过计算机三级网络技术-选择题技巧</title>
      <link href="2021/03/26/computer_grade_3/multiple_choice_skills/"/>
      <url>2021/03/26/computer_grade_3/multiple_choice_skills/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>明天下午就要考计算机三级了，网络技术。。。慌得一批啊，对于计算机三级对网络技术的考察，我通过刷题的得到了许多套路的东西。这一部分就对选择题部分的重要知识点进行记录，方便以后还能够看看，当然能够帮助到别人还是不错的。</p><h2 id="RPR技术"><a href="#RPR技术" class="headerlink" title="RPR技术"></a>RPR技术</h2><ul><li>RPR和FDDI一样采用<strong>双环结构</strong><span id="more"></span></li><li>传统的 FDDI 环，当源结点向目的节点成功发送一个数据帧之后，这个数据帧由<strong>源结点</strong>从环中回收。但 <strong>RPR 环，这个数据帧由目的结点从环中回收</strong>。</li><li>RPR环能够在<strong>50ms</strong>实现自愈</li><li>RPR 环中每一个节点都执行 <strong>SRP 公平算法</strong></li><li>两个 RPR 结点间的裸光纤最大长度可达 100 公里。</li></ul><h2 id="宽带城域网"><a href="#宽带城域网" class="headerlink" title="宽带城域网"></a>宽带城域网</h2><h3 id="汇聚层"><a href="#汇聚层" class="headerlink" title="汇聚层"></a>汇聚层</h3><ul><li>汇接接入层的用户流量，进行数据分组传输的<strong>汇聚、转发与交换</strong></li><li>根据接入层的用户流量，进行本地路由、过滤、流量均衡、QoS 优先级管理，以及安全控制、IP 地址转换、流量整行等处理。</li><li>根据处理结果把用户流量转发到核心交换层或在本地进行路由处理。</li></ul><h2 id="接入技术"><a href="#接入技术" class="headerlink" title="接入技术"></a>接入技术</h2><ul><li>光纤传输系统的<strong>中继距离可达 100km</strong> 以上</li><li>Cable Modom（电缆调制解调器）利用<strong>频分复用(FDM)</strong>的方法将信道分为上行信道和下行信道</li><li>ASDL 使用一对铜双绞线，具有<strong>非对称技术特性</strong></li><li>将传输速率提高到 <strong>54Mbps</strong> 的是 <strong>802.11a 和 802.11g</strong>，<strong>802.11b</strong> 将传输速度提高到 <strong>11Mbps</strong>。</li><li>无线接入技术主要有：WLAN、WiMAX、WiFi、WMAN 和 Ad hoc等。</li><li>APON、DWDM、EPON 是光纤接入技术。</li></ul><h2 id="服务器技术"><a href="#服务器技术" class="headerlink" title="服务器技术"></a>服务器技术</h2><ul><li><strong>热插拔功能</strong>允许用户在不切断电源的情况下更换<strong>硬盘、板卡</strong>、<strong>电源</strong>等（不能更换主板、主背板）。</li><li><strong>磁盘性能</strong>表现在<strong>储存容量</strong>和 <strong>I/O 速度</strong>。</li><li><strong>集群技术</strong>中，如果一台主机出现故障，不会影响正常服务，但会影响系统性能。</li><li>服务器<strong>总体性能</strong>取决于 <strong>CPU 数量、CPU 主频、系统内存、网络速度</strong>(只写 CPU 数量错)</li></ul><h2 id="BGP-协议"><a href="#BGP-协议" class="headerlink" title="BGP 协议"></a>BGP 协议</h2><ul><li>BGP 采用<strong>路由向量协议</strong>，而RIP采用距离向量协议</li><li>BGP 交换路由信息的节点数不小于自治系统数。</li><li>BGP 不同自治系统(AS)的路由器之间使用的协议</li><li>一个 BGP 发言人使用 <strong>TCP（不是 UDP）</strong>与其他自治系统的 BGP发言人交换路由信息。</li><li>BGP 发言人通过 <strong>update</strong> 而不是 noticfication 分组通知相邻系统，使用 update 分组更新路由时，一个报文只能增加一条路由。</li></ul><h2 id="OSPF-协议"><a href="#OSPF-协议" class="headerlink" title="OSPF 协议"></a>OSPF 协议</h2><ul><li>OSPF 通过<strong>划分区域</strong>来提高路由更新收敛速度</li><li>每一个区域都是有一个32位的区域标识符</li><li>区域内路由器不超过 200 个</li><li>一个 OSPF 区域内每个路由器的链路状态数据库包含着<strong>本区域(不是全网)</strong>的拓扑结构信息，不知道其他区域的网络拓扑。</li><li>当链路状态发生变化时用<strong>洪泛法</strong>向所有(不是相邻)路由器发送此信息。</li></ul><h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><ul><li>工作在<strong>物理层</strong>，连接到一个集线器的所有结点共享/属于（不是独立）一个冲突域</li><li>每次只有一个结点能够发送数据，而其他的结点都处于接收数据的状态（<strong>多个节点可以同时接受数据帧</strong>）。连接到集线器的节点发送数据时，该节点将执行 <strong>CSMA/CD（不是 CA）</strong>介质访问控制方法。</li><li>采用 RISC 结构处理器的服务器通常使用 UNIX 系统(不是Windows、Android)。</li><li>RAID 技术可以提磁盘存储容量但是不能提高容错能力</li><li>在网络链路中串接一个集线器可以监听该链路中的数据包。</li></ul><h2 id="布线"><a href="#布线" class="headerlink" title="布线"></a>布线</h2><ul><li>双绞线可以<strong>避免电磁干扰</strong>。</li><li>嵌入式插座用来连接双绞线。（不是连接楼层配线架）</li><li>多介质插座用来连接<strong>铜缆</strong>和<strong>光纤</strong>（写其他的错），满足用户“光纤到桌面”的需求。</li><li>建筑群子系统可以是多种布线方式的任意组合（“一般用双绞线连接”错）。 </li><li>STP比UTP 成本高、复杂，但抗干扰能力强、辐射小</li><li>对于高速率终端可采用光纤直接到桌面的方案</li><li>管理子系统设置在楼层配线间内，提供与其他子系统连接的手段。</li></ul><h2 id="IEEE"><a href="#IEEE" class="headerlink" title="IEEE"></a>IEEE</h2><ul><li>IEEE 802.11 的三个物理层定义包括了<strong>两个扩频技术（FHSS、DSSS）</strong>和<strong>一个红外传播规范</strong>。</li><li>802.11 无线传输频道定义在 2.4GHz ISM 频段，<strong>定义的传输速率是</strong> 1Mbps 和 2Mbps。</li><li>IEEE802.11 在 MAC 子层引入了一个 <strong>RTS/CTS</strong> 选项。</li><li>IEEE802.11 运行在 2.4GHz ISM 频段，最大传输速率是1~2Mbps</li><li>IEEE802.11b 运行在 2.4GHz ISM 频段，最大传输速率是11Mbps，最大容量是 33Mbps</li><li>IEEE 802.1d 是当前最流行的 <strong>STP（生成树协议）标准</strong>。</li><li>点对点模式是指<strong>无线网卡和无线网卡</strong>之间的通信方式。它最多可以允许 <strong>256</strong> 台 PC 连接。</li><li>无线接入点 AP 的作用是提供无线和有线网络之间的桥接，而非无线结点。</li></ul><h2 id="www-服务器"><a href="#www-服务器" class="headerlink" title="www 服务器"></a>www 服务器</h2><ul><li>建立 Web 站点时必须为该站点指定一个<strong>主目录</strong>（不一定在本地计算机/服务器），也可以是<strong>虚拟的子目录</strong>。</li><li>设置了默认页面，访问时才会直接(自动)打开 default.html</li><li><strong>带宽限制选项</strong>限制该网站的可使用带宽；<strong>网站连接选项</strong>可设置客户端 Web 连接数量</li></ul><h2 id="FTP-服务器"><a href="#FTP-服务器" class="headerlink" title="FTP 服务器"></a>FTP 服务器</h2><ul><li>初始状态下没有设置管理员密码，可以直接进入 Serv-U 管理程序</li><li>向服务器中添加“anonymous”，系统自动判定为匿名用户。而不是创建新域时<strong>自动</strong>添加一个“anonymous”匿名。</li><li>FTP 服务器缺省端口号为 <strong>21</strong>，但是有时因为某种原因则不能使用 21 号端口，但可以选择其他合适的端口号。</li><li>服务器可构建多个由 IP 地址和端口号识别的虚拟服务器，每个虚拟服务器（域）<strong>由 IP 地址和端口号唯一识别</strong>，<strong>而不是只依靠 IP 地址。</strong></li></ul><h2 id="邮件（Winmail-邮件服务器）"><a href="#邮件（Winmail-邮件服务器）" class="headerlink" title="邮件（Winmail 邮件服务器）"></a>邮件（Winmail 邮件服务器）</h2><ul><li>Winmail 邮件服务器支持基于 <strong>Web 方式</strong>的访问和管理，因此在安装邮件服务器软件之前要安装 IIS</li><li>Winmail 邮件服务器允许用户自行注册新邮箱，需输入邮箱名、密码等信息，<strong>而域名是服务器固定的，并不能自行设置</strong>。但 Winmail 用户不可以使用 Outlook 自行注册新邮箱。</li><li>在 <strong>Winmail 快速设置向导</strong>（<strong>不是系统设置</strong>）中创建新用户时，输入新建用户的信息，包括用户名、域名及用户密码（不是系统邮箱的密码、管理员密码），可选择是否允许客户通过Winmail 注册新邮箱</li></ul><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><ul><li><p>SYN Flooding 攻击：使用无效的 IP 地址，利用 TCP 连接的三次握手过程，使得受害主机处于开放会话的请求之中，直至连接超时。在此期间，受害主机将会连续接受这种会话请求,最终因耗尽资源而停止响应。</p></li><li><p>DDos 攻击：利用攻破的多个系统发送大量请求去集中攻击其他目标，受害设备因为无法处理而拒绝服务。</p></li><li><p>SQL 注入攻击：属于利用系统漏洞，基于网络的入侵防护系统和基于主机入侵防护系统都难以阻断。<strong>防火墙（基于网络的防护系统）无法阻断这种攻击。</strong></p></li><li><p>Land 攻击：向某个设备发送数据包，并将数据包的源 IP 地址和目的地址都设置成攻击目标的地址。</p></li><li><p>协议欺骗攻击：通过伪造某台主机的 IP 地址窃取特权的攻击。有以下几种：（1）IP 欺骗攻击。（2）ARP 欺骗攻击。（3）DNS 欺骗攻击。（4）源路由欺骗攻击。</p></li><li><p>DNS 欺骗攻击：攻击者采用某种欺骗手段，使用户查询服务器进行域名解析时获得一个错误的 IP 地址，从而可将用户引导到错误的 Internet 站点。</p></li><li><p>IP 欺骗攻击：通过伪造某台主机的 IP 地址骗取特权，进而进行攻击的技术。</p></li><li><p>Cookie 篡改攻击：通过对 Cookie 的篡改可以实现非法访问目标站点，基于网络的入侵防护系统无法阻断。</p></li><li><p>Smurf 攻击：攻击者冒充受害主机的 IP 地址，向一个大的网络发送 echo request 的定向广播包，此网络的许多主机都做出回应，受害主机会收到大龄的 echo reply 消息。基于网络的入侵防护系统可以阻断 Smurf 攻击。</p></li><li><p>基于网络的防护系统无法阻断 <strong>Cookie 篡改</strong>、<strong>DNS 欺骗</strong>、<strong>SQL注入</strong>。</p></li><li><p>基于网络的入侵防护系统和基于主机入侵防护系统都难以阻断的是跨站脚本攻击、SQL 注入攻击。 </p></li></ul><h2 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><ul><li>VLAN 以交换式网络为基础。</li><li>VLAN 工作在 OSI 参考模型的第二层(数据链路层)，而不是网络层。VLAN 之间通信必须通过路由器。</li></ul><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><ul><li>工作频段在 2.402GHz~2.480GHz 的ISM 频段。</li><li>同步信道速率 64kbps。</li><li>标称数据速率是 1Mbps。</li><li>非对称的异步信道速率为 723.2kbps/57.6kbps，对称的异步信道速率为 433.9kbps（全双工）。</li></ul><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><ul><li>高性能路由器一般采用采用可交换式的结构，传统的核心路 由器采用共字背板的结构。</li><li>丢包率是衡量路由器超负荷工作时的性能指标之一。(“路由表容量”不是) </li><li>吞吐量是指路由器的包转发能力，包括端口吞吐量与整机吞吐量。背板能力决定路由器吞吐量。（不是吞吐量决定了路由器的背板能力） </li></ul><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><ul><li><p>无源光纤网FPON，按照ITU标准可分为两部分:(1) <strong>OC-3，155.520 Mbps</strong> 的对称业务。(2) <strong>上行OC-3，155.520 Mbps</strong>，下行<strong>0C-12, 622.080 Mbps</strong>的不对称业务。</p></li><li><p>全双工端口的带宽计算方法：<strong>端口数x端口速率x2</strong>.</p></li><li><p><strong>ipconfig</strong>显示当前TCP/ITP网络配置，<strong>netstat</strong>显示本机与远程计算机的基于TCP/IP的NeTBIOS的统计及连接信息，<strong>pathping</strong>将报文发送到所经过地所有路由器，并根据每一跳返回的报文进行统计;<strong>route</strong>显示或修改本地IP路由表条目。</p></li><li><p>三种备份的比较：</p><p>| 比较     |          | 有大到小， 由快到慢 |          |<br>| ———— | ———— | :————————-: | ———— |<br>| 空间使用 | 完全备份 |      差异备份       | 增量备份 |<br>| 备份速度 | 增量备份 |      差异备份       | 完全备份 |<br>| 恢复速度 | 完全备份 |      差异备份       | 增量备份 |</p></li><li><p>Cisco PIX 525防火墙：</p><ul><li>特权模式：PIX防火墙开机自检后，即处于此种模式。</li><li>非特权模式：</li><li>监视模式：可以进行操作系统映像更新和口令恢复</li><li>配置模式：</li></ul></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/56552345">计算机三级网络技术笔记（精华版）写文章</a> </p>]]></content>
      
      
      <categories>
          
          <category> 计算机三级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建个人博客</title>
      <link href="2021/02/26/Blog/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>2021/02/26/Blog/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>我是在<strong>Ubuntu 20.04</strong> 下面搭建的博客，所以下面记录操作的命令都是针对于Ubuntu下面的命令。对于Windows下面的搭建，现在暂时还没有尝试，以后遇到了再更新操作。特别说明该个人博客是基于<strong>hexo</strong>框架搭建的，服务端是交于<strong>github</strong>管理的。</p><span id="more"></span><h2 id="安装nodejs-npm"><a href="#安装nodejs-npm" class="headerlink" title="安装nodejs, npm"></a>安装nodejs, npm</h2><p>因为hexo框架是依赖于nodejs，所以我们需要先安装好<strong>nodejs</strong>和包管理器<strong>nmp</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nodejs npm</span><br></pre></td></tr></table></figure><p>查看是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node --version</span><br><span class="line">npm --version</span><br></pre></td></tr></table></figure><p>正常输出就安装成功了。</p><h2 id="安装cnmp"><a href="#安装cnmp" class="headerlink" title="安装cnmp"></a>安装cnmp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>这里要加入源，我用的是taobao源。检查一下安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><h2 id="安装hexo框架"><a href="#安装hexo框架" class="headerlink" title="安装hexo框架"></a>安装hexo框架</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>检查一下安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h2 id="创建博客目录并初始化"><a href="#创建博客目录并初始化" class="headerlink" title="创建博客目录并初始化"></a>创建博客目录并初始化</h2><p>我在家目录下面创建了一个<code>~/PersonalBlog/</code>，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir PersonalBlog &amp;&amp; cd PersonalBlog</span><br></pre></td></tr></table></figure><p><strong>hexo</strong>初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm audix fix</span><br></pre></td></tr></table></figure><p>本地运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>点击 <a href="http://localhost:4000">http://localhost:4000</a> ，博客页面在本地就有了。</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325111017.png" alt="image-20210225150228015"></p><h2 id="创建第一篇博客"><a href="#创建第一篇博客" class="headerlink" title="创建第一篇博客"></a>创建第一篇博客</h2><p>创建第一篇博客：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;My First Blog&quot;</span><br></pre></td></tr></table></figure><p>然后vim向 <code>~/PersonalBlog/source/_posts/My-First-Blog.md</code> 随便写入：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325111603.png" alt="image-20210325111602924"></p><p><code>:wq</code>退出</p><p>然后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>看看效果：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325111730.png" alt="image-20210325111730245"></p><h2 id="github服务端部署"><a href="#github服务端部署" class="headerlink" title="github服务端部署"></a>github服务端部署</h2><p>在github账户下创建一个仓库，仓库名必须是：<strong>xxx.github.io</strong>，所以我的就是<code>miller-em.github.io</code>，欢迎访问，哈哈哈。</p><p>安装hexo-deployer-git:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><p>修改博客根目录下的<code>_config.yml</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure><p>最后这里修改一下：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325111808.png" alt="image-20210325111807897"></p><p>保存退出后，推向github服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>输入你的github用户名和密码，成功后在浏览器输入：xxx.github.io，看看效果：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325111838.png" alt="image-20210325111838715"></p><p>到这里，你的个人博客搭建就完成了！</p><h2 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h2><p>我觉得原始主题不太符合我的style，所以我就换了一个主题。我用的是nexT主题，黑白配色简约淡雅。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git themes&#x2F;next</span><br></pre></td></tr></table></figure><p>修改<code>_config.yml</code>，将主题改为next：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325111948.png" alt="image-20210325111948090"></p><h2 id="配置NexT"><a href="#配置NexT" class="headerlink" title="配置NexT"></a>配置NexT</h2><ol><li><p>设置博客根目录下_config.yml：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325112005.png" alt="image-20210325112005322"></p></li><li><p>设置菜单栏：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325112020.png" alt="image-20210325112020464"></p><p>在<code>themes/next/_config.yml</code>下面的查看menu.</p><p>在根目录下面，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;about&quot; </span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page &quot;archives&quot;</span><br><span class="line">hexo new page &quot;search&quot;</span><br></pre></td></tr></table></figure><p>此时在根目录的sources文件夹下会生成categories、tags、about、archives、search四个文件，每个文件中有一个<code>index.md</code>文件：</p></li><li><p>设置建站时间</p><p>打开主题配置文件即themes/next下的_config.yml，查找since：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup. If not defined, current year will be used.</span><br><span class="line">  since: 2021-02</span><br></pre></td></tr></table></figure></li><li><p>设置头像</p><p>打开主题配置文件即themes/next下的_config.yml，查找avatar，url后是图片的链接地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: &#x2F;images&#x2F;avatar.gif</span><br><span class="line">  # If true, the avatar will be dispalyed in circle.</span><br><span class="line">  rounded: true</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: tru</span><br></pre></td></tr></table></figure></li><li><p>网站图标设置</p><p>我是在这个网站找的图标，免费的图标素材网站：<a href="https://link.zhihu.com/?target=https%3A//www.easyicon.net/1220579-maple_leaf_icon.html">Easyicon</a></p><p>下载16x16和32x32的图标后，打开主题配置文件，查找favicon，只要修改small和medium为你的图标路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: &#x2F;images&#x2F;favicon-16x16-next.png</span><br><span class="line">  medium: &#x2F;images&#x2F;favicon-32x32-next.png</span><br><span class="line">  apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: &#x2F;images&#x2F;logo.svg</span><br><span class="line">  #android_manifest: &#x2F;images&#x2F;manifest.json</span><br><span class="line">  #ms_browserconfig: &#x2F;images&#x2F;browserconfig.xml</span><br></pre></td></tr></table></figure></li><li><p>设置博文内链接为蓝色</p><p>打开themes/next/source/css/_common/components/post/post.styl文件，将下面的代码复制到文件最后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">     color: #0593d3;</span><br><span class="line">     border-bottom: none;</span><br><span class="line">     &amp;:hover &#123;</span><br><span class="line">       color: #0477ab;</span><br><span class="line">       text-decoration: underline;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>显示文章字数和阅读时长</p><p>从根目录Blog打开Git Bash，执行下面的命令，安装插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>然后打开<strong>站点配置文件，</strong>在文件末尾加上下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true                # 文章字数统计</span><br><span class="line">  time: true                   # 文章阅读时长</span><br><span class="line">  total_symbols: true          # 站点总字数统计</span><br><span class="line">  total_time: true             # 站点总阅读时长</span><br><span class="line">  exclude_codeblock: false     # 排除代码字数统计</span><br></pre></td></tr></table></figure></li><li><p>添加Fork me on Github</p><p>选择你喜欢的类型，打开<a href="https://link.zhihu.com/?target=http%3A//tholman.com/github-corners/">小猫</a>或者<a href="https://link.zhihu.com/?target=https%3A//github.blog/2008-12-19-github-ribbons/">字</a>，复制代码添加到themes/next/layout/_layout.swig文件中，放在<div class="headband"></div>后面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;headband&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;Miller_em&quot; class&#x3D;&quot;github-corner&quot; ....</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>www.codesheep.com</p><p><a href="https://zhuanlan.zhihu.com/p/106060640">个人博客第8篇——优化主题（持续更新）</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Pytorch训练一个图像分类器</title>
      <link href="2021/02/26/deep_learning/%E5%88%A9%E7%94%A8pytorch%E8%AE%AD%E7%BB%83%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E5%99%A8/"/>
      <url>2021/02/26/deep_learning/%E5%88%A9%E7%94%A8pytorch%E8%AE%AD%E7%BB%83%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>学习一个框架最快的方式就是，自己利用框架针对某个案例自己敲一遍。而作为一个AI视觉者，入门的案例肯定是图像分类，所以，我选择了pytorch官网里的tutorials的一个例子。对于深度学习来说，肯定要经过下面几个步骤：<strong>数据处理（类型转换，归一化）</strong>， <strong>搭建网络结构</strong>，<strong>训练</strong>，<strong>测试</strong>，<strong>导出/加载模型</strong>。下面我将会用这个例子实践以上方面，加深对Pytorch基本语法的掌握。</p> <span id="more"></span><h2 id="关于数据"><a href="#关于数据" class="headerlink" title="关于数据"></a>关于数据</h2><p>一般来说，当你用pytorch来做深度学习有关的事情的时候，比如说处理图像，音频，文本和视频，你都是需要用一些python的包来将numpy类型的数据转化为<code>torch *Tensor</code></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
            <tag> python </tag>
            
            <tag> classfication </tag>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
