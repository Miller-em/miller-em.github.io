<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MYSQL基本操作</title>
      <link href="2021/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>2021/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。</p><p>打开命令提示符，输入命令<code>mysql -u root -p</code>，提示输入口令。填入MySQL的root口令，如果正确，就连上了MySQL Server，同时提示符变为<code>mysql&gt;</code>：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></tbody></table></figure><p>输入<code>exit</code>断开与MySQL Server的连接并返回到命令提示符。</p><p>MySQL Client和MySQL Server的关系如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┐  SQL   ┌──────────────┐</span><br><span class="line">│ MySQL Client │───────&gt;│ MySQL Server │</span><br><span class="line">└──────────────┘  TCP   └──────────────┘</span><br></pre></td></tr></tbody></table></figure><p>在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是<code>127.0.0.1:3306</code>。</p><p>也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是<code>10.0.1.99</code>，那么就使用<code>-h</code>指定IP或域名：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h <span class="number">10.0</span><span class="number">.1</span><span class="number">.99</span> <span class="operator">-</span>u root <span class="operator">-</span>p</span><br></pre></td></tr></tbody></table></figure><h2 id="管理MySQL"><a href="#管理MySQL" class="headerlink" title="管理MySQL"></a>管理MySQL</h2><p>要管理MySQL，可以使用可视化图形界面<a href="https://dev.mysql.com/downloads/workbench/">MySQL Workbench</a>。</p><p>MySQL Workbench可以用可视化的方式查询、创建和修改数据库表，但是，归根到底，MySQL Workbench是一个图形客户端，它对MySQL的操作仍然是发送SQL语句并执行。因此，本质上，MySQL Workbench和MySQL Client命令行都是客户端，和MySQL交互，唯一的接口就是SQL。</p><p>因此，MySQL提供了大量的SQL语句用于管理。虽然可以使用MySQL Workbench图形界面来直接管理MySQL，但是，很多时候，通过SSH远程连接时，只能使用SQL命令，所以，了解并掌握常用的SQL管理操作是必须的。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></tbody></table></figure><p>要创建一个新数据库，使用命令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE test;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></tbody></table></figure><p>要删除一个数据库，使用命令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP DATABASE test;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></tbody></table></figure><p><strong>注意：删除一个数据库将导致该数据库的所有表全部被删除。</strong></p><p>对一个数据库进行操作时，要首先将其切换为当前数据库：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE test;</span><br><span class="line">Database changed</span><br></pre></td></tr></tbody></table></figure><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>列出当前数据库的所有表，使用命令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br></pre></td></tr></tbody></table></figure><p>要查看一个表的结构，使用命令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DESC students;</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id       | bigint(20)   | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| class_id | bigint(20)   | NO   |     | NULL    |                |</span><br><span class="line">| name     | varchar(100) | NO   |     | NULL    |                |</span><br><span class="line">| gender   | varchar(1)   | NO   |     | NULL    |                |</span><br><span class="line">| score    | int(11)      | NO   |     | NULL    |                |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure><p>还可以使用以下命令查看创建表的SQL语句：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE TABLE students;</span><br><span class="line">+----------+-------------------------------------------------------+</span><br><span class="line">| students | CREATE TABLE `students` (                             |</span><br><span class="line">|          |   `id` bigint(20) NOT NULL AUTO_INCREMENT,            |</span><br><span class="line">|          |   `class_id` bigint(20) NOT NULL,                     |</span><br><span class="line">|          |   `name` varchar(100) NOT NULL,                       |</span><br><span class="line">|          |   `gender` varchar(1) NOT NULL,                       |</span><br><span class="line">|          |   `score` int(11) NOT NULL,                           |</span><br><span class="line">|          |   PRIMARY KEY (`id`)                                  |</span><br><span class="line">|          | ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 |</span><br><span class="line">+----------+-------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure><p>创建表使用<code>CREATE TABLE</code>语句，而删除表使用<code>DROP TABLE</code>语句：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP TABLE students;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></tbody></table></figure><p>修改表就比较复杂。如果要给<code>students</code>表新增一列<code>birth</code>，使用：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br></pre></td></tr></tbody></table></figure><p>要修改<code>birth</code>列，例如把列名改为<code>birthday</code>，类型改为<code>VARCHAR(20)</code>：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br></pre></td></tr></tbody></table></figure><p>要删除列，使用：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br></pre></td></tr></tbody></table></figure><h3 id="退出MySQL"><a href="#退出MySQL" class="headerlink" title="退出MySQL"></a>退出MySQL</h3><p>使用<code>EXIT</code>命令退出MySQL：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXIT</span><br><span class="line">Bye</span><br></pre></td></tr></tbody></table></figure><p>注意<code>EXIT</code>仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。</p><h2 id="实用SQL语句"><a href="#实用SQL语句" class="headerlink" title="实用SQL语句"></a>实用SQL语句</h2><p>在编写SQL时，灵活运用一些技巧，可以大大简化程序逻辑。</p><h3 id="插入或替换"><a href="#插入或替换" class="headerlink" title="插入或替换"></a>插入或替换</h3><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<code>REPLACE</code>语句，这样就不必先查询，再决定是否先删除再插入：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99);</span><br></pre></td></tr></tbody></table></figure><p>若<code>id=1</code>的记录不存在，<code>REPLACE</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被删除，然后再插入新记录。</p><h3 id="插入或更新"><a href="#插入或更新" class="headerlink" title="插入或更新"></a>插入或更新</h3><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用<code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99) ON DUPLICATE KEY UPDATE name='小明', gender='F', score=99;</span><br></pre></td></tr></tbody></table></figure><p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被更新，更新的字段由<code>UPDATE</code>指定。</p><h3 id="插入或忽略"><a href="#插入或忽略" class="headerlink" title="插入或忽略"></a>插入或忽略</h3><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99);</span><br></pre></td></tr></tbody></table></figure><p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，不执行任何操作。</p><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合<code>CREATE TABLE</code>和<code>SELECT</code>：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:</span><br><span class="line">CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1;</span><br></pre></td></tr></tbody></table></figure><p>新创建的表结构和<code>SELECT</code>使用的表结构完全一致。</p><h3 id="写入查询结果集"><a href="#写入查询结果集" class="headerlink" title="写入查询结果集"></a>写入查询结果集</h3><p>如果查询结果集需要写入到表中，可以结合<code>INSERT</code>和<code>SELECT</code>，将<code>SELECT</code>语句的结果集直接插入到指定表中。</p><p>例如，创建一个统计成绩的表<code>statistics</code>，记录各班的平均成绩：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE statistics (</span><br><span class="line">    id BIGINT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    class_id BIGINT NOT NULL,</span><br><span class="line">    average DOUBLE NOT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>然后，我们就可以用一条语句写入各班的平均成绩：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id;</span><br></pre></td></tr></tbody></table></figure><p>确保<code>INSERT</code>语句的列和<code>SELECT</code>语句的列能一一对应，就可以在<code>statistics</code>表中直接保存查询的结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM statistics;</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">| id | class_id | average      |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">|  1 |        1 |         86.5 |</span><br><span class="line">|  2 |        2 | 73.666666666 |</span><br><span class="line">|  3 |        3 | 88.333333333 |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure><h3 id="强制使用指定索引"><a href="#强制使用指定索引" class="headerlink" title="强制使用指定索引"></a>强制使用指定索引</h3><p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用<code>FORCE INDEX</code>强制查询使用指定的索引。例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC;</span><br></pre></td></tr></tbody></table></figure><p>指定索引的前提是索引<code>idx_class_id</code>必须存在。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL基础知识</title>
      <link href="2021/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2021/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>什么是SQL？简单地说，SQL就是访问和处理关系数据库的计算机标准语言。也就是说，无论用什么编程语言（Java、Python、C++……）编写程序，只要涉及到操作关系数据库，比如，一个电商网站需要把用户和商品信息存入数据库，或者一个手机游戏需要把用户的道具、通关信息存入数据库，都必须通过SQL来完成。SQL是结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。</p><span id="more"></span><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><p>关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。</p><ul><li><p>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。</p></li><li><p>表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。</p></li></ul><p>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为<strong>NULL</strong>。注意<code>NULL</code>表示字段数据不存在。一个整型字段如果为<code>NULL</code>不表示它的值为<code>0</code>，同样的，一个字符串型字段为<code>NULL</code>也不表示它的值为空串<code>''</code>。</p><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<em>主键</em>。例如，假设我们把<code>name</code>字段作为主键，那么通过名字<code>小明</code>或<code>小红</code>就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为插入相同主键的两条记录是不被允许的。<strong>选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。</strong></p><h4 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h4><p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。对于联合主键，<strong>允许</strong>一列有重复，<strong>只要不是所有主键列都重复</strong>即可：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210717194759.png" alt="image-20210717194750119"></p><p>如果我们把上述表的<code>id_num</code>和<code>id_type</code>这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。</p><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210717195138.png" alt="image-20210717195138081"></p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210717195145.png" alt="image-20210717195145053"></p><p>如何确定<code>students</code>表的一条记录，例如，<code>id=1</code>的小明，属于哪个班级呢？</p><p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个<code>classes</code>的记录可以对应多个<code>students</code>表的记录。</p><p>为了表达这种一对多的关系，我们需要在<code>students</code>表中加入一列<code>class_id</code>，让它的值与<code>classes</code>表的某条记录相对应：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210717195233.png" alt="image-20210717195233748"></p><p>这样，我们就可以根据<code>class_id</code>这个列直接定位出一个<code>students</code>表的记录应该对应到<code>classes</code>的哪条记录。</p><p>在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为<strong>外键</strong>。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_class_id <span class="operator">/</span><span class="operator">/</span>外键约束的名称fk_class_id可以任意</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (class_id)   <span class="operator">/</span><span class="operator">/</span>指定了class_id作为外键</span><br><span class="line"><span class="keyword">REFERENCES</span> classes (id); <span class="operator">/</span><span class="operator">/</span>指定了这个外键将关联到classes表的id列</span><br></pre></td></tr></tbody></table></figure><p>要删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_class_id;</span><br></pre></td></tr></tbody></table></figure><p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</p><p>所以，<strong>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证</strong>。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。<strong>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构</strong>。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p><p>例如，对于<code>students</code>表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">id</th><th style="text-align:left">class_id</th><th style="text-align:left">name</th><th style="text-align:left">gender</th><th style="text-align:left">score</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">小明</td><td style="text-align:left">M</td><td style="text-align:left">90</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">1</td><td style="text-align:left">小红</td><td style="text-align:left">F</td><td style="text-align:left">95</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">1</td><td style="text-align:left">小军</td><td style="text-align:left">M</td><td style="text-align:left">88</td></tr></tbody></table></div><p>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_score (score);</span><br></pre></td></tr></tbody></table></figure><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p><p>但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设<code>students</code>表的<code>name</code>不能重复：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD UNIQUE INDEX uni_name (name);</span><br></pre></td></tr></tbody></table></figure><p>通过<code>UNIQUE</code>关键字我们就添加了一个唯一索引。</p><p>也可以只对某一列添加一个唯一约束而不创建唯一索引：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT uni_name UNIQUE (name);</span><br></pre></td></tr></tbody></table></figure><p>这种情况下，<code>name</code>列没有索引，但仍然具有唯一性保证。</p><p>无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。</p><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>在关系数据库中，最常用的操作就是查询。</p><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><p>要查询数据库表的数据，我们使用如下的SQL语句：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt;</span><br></pre></td></tr></tbody></table></figure><p>假设表名是<code>students</code>，要查询<code>students</code>表的所有行，我们用如下SQL语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></tbody></table></figure><p>使用<code>SELECT * FROM students</code>时，<code>SELECT</code>是关键字，表示将要执行一个查询，<code>*</code>表示“所有列”，<code>FROM</code>表示将要从哪个表查询，本例中是<code>students</code>表。</p><p>要查询<code>classes</code>表的所有行，我们用如下SQL语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> classes;</span><br></pre></td></tr></tbody></table></figure><p><code>SELECT</code>语句其实并不要求一定要有<code>FROM</code>子句。我们来试试下面的<code>SELECT</code>语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">+</span><span class="number">200</span>;</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="number">300</span></span><br></pre></td></tr></tbody></table></figure><p>上述查询会直接计算出表达式的结果。虽然<code>SELECT</code>可以用作计算，但它并不是SQL的强项。但是，不带<code>FROM</code>子句的<code>SELECT</code>语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条<code>SELECT 1;</code>来测试数据库连接。</p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>使用<code>SELECT * FROM &lt;表名&gt;</code>可以查询到一张表的所有记录。但是，很多时候，我们并不希望获得所有记录，而是根据条件选择性地获取指定条件的记录，例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。</p><p>SELECT语句可以通过<code>WHERE</code>条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成<code>WHERE</code>条件就是<code>SELECT * FROM students WHERE score &gt;= 80</code>。</p><p>其中，<code>WHERE</code>关键字后面的<code>score &gt;= 80</code>就是条件。<code>score</code>是列名，该列存储了学生的成绩，因此，<code>score &gt;= 80</code>就筛选出了指定条件的记录：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> score <span class="operator">&gt;=</span> <span class="number">80</span>;</span><br></pre></td></tr></tbody></table></figure><p>因此，条件查询的语法就是：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>条件表达式可以用<code>&lt;条件1&gt; AND &lt;条件2&gt;</code>表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来：</p><ul><li>条件1：根据score列的数据判断：<code>score &gt;= 80</code>；</li><li>条件2：根据gender列的数据判断：<code>gender = 'M'</code>，注意<code>gender</code>列存储的是字符串，需要用单引号括起来。</li></ul><p>就可以写出<code>WHERE</code>条件：<code>score &gt;= 80 AND gender = 'M'</code>：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> score <span class="operator">&gt;=</span> <span class="number">80</span> <span class="keyword">AND</span> gender <span class="operator">=</span> <span class="string">'M'</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="常用的条件表达式"><a href="#常用的条件表达式" class="headerlink" title="常用的条件表达式"></a>常用的条件表达式</h4><div class="table-container"><table><thead><tr><th style="text-align:left">条件</th><th style="text-align:left">表达式举例1</th><th style="text-align:left">表达式举例2</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">使用=判断相等</td><td style="text-align:left">score = 80</td><td style="text-align:left">name = ‘abc’</td><td style="text-align:left">字符串需要用单引号括起来</td></tr><tr><td style="text-align:left">使用&gt;判断大于</td><td style="text-align:left">score &gt; 80</td><td style="text-align:left">name &gt; ‘abc’</td><td style="text-align:left">字符串比较根据ASCII码，中文字符比较根据数据库设置</td></tr><tr><td style="text-align:left">使用&gt;=判断大于或相等</td><td style="text-align:left">score &gt;= 80</td><td style="text-align:left">name &gt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用&lt;判断小于</td><td style="text-align:left">score &lt; 80</td><td style="text-align:left">name &lt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用&lt;=判断小于或相等</td><td style="text-align:left">score &lt;= 80</td><td style="text-align:left">name &lt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用&lt;&gt;判断不相等</td><td style="text-align:left">score &lt;&gt; 80</td><td style="text-align:left">name &lt;&gt; ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用LIKE判断相似</td><td style="text-align:left">name LIKE ‘ab%’</td><td style="text-align:left">name LIKE ‘%bc%’</td><td style="text-align:left">%表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’</td></tr></tbody></table></div><p> 查询分数在60分(含)～90分(含)之间的学生可以使用的WHERE语句是：</p><ul><li><p>WHERE score &gt;= 60 OR score &lt;= 90</p></li><li><p>WHERE score &gt;= 60 AND score &lt;= 90</p></li><li><p>WHERE score IN (60, 90)</p></li><li><p>WHERE score BETWEEN 60 AND 90</p></li><li><p>WHERE 60 &lt;= score &lt;= 90</p></li></ul><h3 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h3><p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用<code>SELECT 列1, 列2, 列3 FROM ...</code>，让结果集仅包含指定列。这种操作称为投影查询。</p><p>例如，从<code>students</code>表中返回<code>id</code>、<code>score</code>和<code>name</code>这三列：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, score, name <span class="keyword">FROM</span> students;</span><br></pre></td></tr></tbody></table></figure><p>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>。</p><p>例如，以下<code>SELECT</code>语句将列名<code>score</code>重命名为<code>points</code>，而<code>id</code>和<code>name</code>列名保持不变：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, score points, name <span class="keyword">FROM</span> students;</span><br></pre></td></tr></tbody></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>我们使用SELECT查询时，细心的读者可能注意到，查询结果集通常是按照<code>id</code>排序的，也就是根据主键排序。这也是大部分数据库的做法。如果我们要根据其他条件排序怎么办？可以加上<code>ORDER BY</code>子句。例如按照成绩从低到高进行排序：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score;</span><br></pre></td></tr></tbody></table></figure><p>如果要反过来，按照成绩从高到底排序，我们可以加上<code>DESC</code>表示“倒序”：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br></pre></td></tr></tbody></table></figure><p>如果<code>score</code>列有相同的数据，要进一步排序，可以继续添加列名。例如，使用<code>ORDER BY score DESC, gender</code>表示先按<code>score</code>列倒序，如果有相同分数的，再按<code>gender</code>列排序：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>, gender;</span><br></pre></td></tr></tbody></table></figure><p>默认的排序规则是<code>ASC</code>：“升序”，即从小到大。<code>ASC</code>可以省略，即<code>ORDER BY score ASC</code>和<code>ORDER BY score</code>效果一样。如果有<code>WHERE</code>子句，那么<code>ORDER BY</code>子句要放到<code>WHERE</code>子句后面。例如，查询一班的学生成绩，并按照倒序排序：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> class_id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。</p><p>要实现分页功能，实际上就是从结果集中显示第1-100条记录作为第1页，显示第101-200条记录作为第2页，以此类推。</p><p>因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>子句实现。我们先把所有学生按照成绩从高到低进行排序：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br></pre></td></tr></tbody></table></figure><p>现在，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用<code>LIMIT 3 OFFSET 0</code>：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">0</span>; <span class="operator">/</span><span class="operator">/</span>对结果集从<span class="number">0</span>号记录开始，最多取<span class="number">3</span>条。注意<span class="keyword">SQL</span>记录集的索引从<span class="number">0</span>开始</span><br></pre></td></tr></tbody></table></figure><p>如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把<code>OFFSET</code>设定为3：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT 3 OFFSET 3;</span><br></pre></td></tr></tbody></table></figure><h3 id="聚合排序"><a href="#聚合排序" class="headerlink" title="聚合排序"></a>聚合排序</h3><p>如果我们要统计一张表的数据量，例如，想查询<code>students</code>表一共有多少条记录，难道必须用<code>SELECT * FROM students</code>查出来然后再数一数有多少行吗？</p><p>这个方法当然可以，但是比较弱智。对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。</p><p>仍然以查询<code>students</code>表一共有多少条记录为例，我们可以使用SQL内置的<code>COUNT()</code>函数查询：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> students;</span><br></pre></td></tr></tbody></table></figure><p><code>COUNT(*)</code>表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是<code>COUNT(*)</code>。</p><p>通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) num <span class="keyword">FROM</span> students;</span><br></pre></td></tr></tbody></table></figure><p><code>COUNT(*)</code>和<code>COUNT(id)</code>实际上是一样的效果。另外注意，聚合查询同样可以使用<code>WHERE</code>条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) boys <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender <span class="operator">=</span> <span class="string">'M'</span>;</span><br></pre></td></tr></tbody></table></figure><p>除了<code>COUNT()</code>函数外，SQL还提供了如下聚合函数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">SUM</td><td style="text-align:left">计算某一列的合计值，该列必须为数值类型</td></tr><tr><td style="text-align:left">AVG</td><td style="text-align:left">计算某一列的平均值，该列必须为数值类型</td></tr><tr><td style="text-align:left">MAX</td><td style="text-align:left">计算某一列的最大值</td></tr><tr><td style="text-align:left">MIN</td><td style="text-align:left">计算某一列的最小值</td></tr></tbody></table></div><p>注意，<code>MAX()</code>和<code>MIN()</code>函数并<strong>不限于</strong>数值类型。如果是字符类型，<code>MAX()</code>和<code>MIN()</code>会返回排序最后和排序最前的字符。</p><p>要统计男生的平均成绩，我们用下面的聚合查询：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(score) average <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender <span class="operator">=</span> <span class="string">'M'</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>要特别注意：如果聚合查询的<code>WHERE</code>条件没有匹配到任何行，<code>COUNT()</code>会返回0，而<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>和<code>MIN()</code>会返回<code>NULL</code>：</strong></p><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>如果我们要统计一班的学生数量，我们知道，可以用<code>SELECT COUNT(*) num FROM students WHERE class_id = 1;</code>。如果要继续统计二班、三班的学生数量，难道必须不断修改<code>WHERE</code>条件来执行<code>SELECT</code>语句吗？</p><p>对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> class_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) num <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;</span><br></pre></td></tr></tbody></table></figure><p><code>GROUP BY</code>子句指定了按<code>class_id</code>分组</p><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：<code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;</code>。</p><p>例如，同时从<code>students</code>表和<code>classes</code>表的“乘积”，即查询数据，可以这么写：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students, classes;</span><br></pre></td></tr></tbody></table></figure><p>投影查询的“设置列的别名”来给两个表各自的<code>id</code>和<code>name</code>列起别名：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    students.id sid,</span><br><span class="line">    students.name,</span><br><span class="line">    students.gender,</span><br><span class="line">    students.score,</span><br><span class="line">    classes.id cid,</span><br><span class="line">    classes.name cname</span><br><span class="line"><span class="keyword">FROM</span> students, classes;</span><br></pre></td></tr></tbody></table></figure><p>注意，多表查询时，要使用<code>表名.列名</code>这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用<code>表名.列名</code>这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s.id sid,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line"><span class="keyword">FROM</span> students s, classes c;</span><br></pre></td></tr></tbody></table></figure><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。</p><p>例如，我们想要选出<code>students</code>表的所有学生信息，可以用一条简单的SELECT语句完成：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, s.gender, s.score <span class="keyword">FROM</span> students s;</span><br></pre></td></tr></tbody></table></figure><p>但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有<code>class_id</code>列，缺少对应班级的<code>name</code>列。</p><p>现在问题来了，存放班级名称的<code>name</code>列存储在<code>classes</code>表中，只有根据<code>students</code>表的<code>class_id</code>，找到<code>classes</code>表对应的行，再取出<code>name</code>列，就可以获得班级名称。</p><p>这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></tbody></table></figure><p>注意INNER JOIN查询的写法是：</p><ol><li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li><li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li><li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li><li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li></ol><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，我们已经详细讲述了<code>SELECT</code>语句的详细用法。</p><p>而对于增、删、改，对应的SQL语句分别是：</p><ul><li>INSERT：插入新记录；</li><li>UPDATE：更新已有记录；</li><li>DELETE：删除已有记录。</li></ul><p>我们将分别讨论这三种修改数据的语句的使用方法。</p><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><p>当我们需要向数据库表中插入一条新记录时，就必须使用<code>INSERT</code>语句。</p><p><code>INSERT</code>语句的基本语法是：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> (字段<span class="number">1</span>, 字段<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br></pre></td></tr></tbody></table></figure><p>例如，我们向<code>students</code>表插入一条新记录，先列举出需要插入的字段名称，然后在<code>VALUES</code>子句中依次写出对应字段的值：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (class_id, name, gender, score) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'大牛'</span>, <span class="string">'M'</span>, <span class="number">80</span>);</span><br><span class="line"><span class="comment">-- 查询并观察结果:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></tbody></table></figure><p>还可以一次性添加多条记录，只需要在<code>VALUES</code>子句中指定多个记录值，每个记录是由<code>(...)</code>包含的一组值：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (class_id, name, gender, score) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">'大宝'</span>, <span class="string">'M'</span>, <span class="number">87</span>),</span><br><span class="line">  (<span class="number">2</span>, <span class="string">'二宝'</span>, <span class="string">'M'</span>, <span class="number">81</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></tbody></table></figure><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>如果要更新数据库表中的记录，我们就必须使用<code>UPDATE</code>语句。</p><p><code>UPDATE</code>语句的基本语法是：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">SET</span> 字段<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>, 字段<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>, ... <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></tbody></table></figure><p>例如，我们想更新<code>students</code>表<code>id=1</code>的记录的<code>name</code>和<code>score</code>这两个字段，先写出<code>UPDATE students SET name='大牛', score=66</code>，然后在<code>WHERE</code>子句中写出需要更新的行的筛选条件<code>id=1</code>：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE students <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">'大牛'</span>, score<span class="operator">=</span><span class="number">66</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查询并观察结果:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>在<code>UPDATE</code>语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE students <span class="keyword">SET</span> score<span class="operator">=</span>score<span class="operator">+</span><span class="number">10</span> <span class="keyword">WHERE</span> score<span class="operator">&lt;</span><span class="number">80</span>;</span><br><span class="line"><span class="comment">-- 查询并观察结果:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></tbody></table></figure><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>如果要删除数据库表中的记录，我们可以使用<code>DELETE</code>语句。</p><p><code>DELETE</code>语句的基本语法是：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></tbody></table></figure><p>例如，我们想删除<code>students</code>表中<code>id=1</code>的记录，就需要这么写：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查询并观察结果:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></tbody></table></figure><p>注意到<code>DELETE</code>语句的<code>WHERE</code>条件也是用来筛选需要删除的行，因此和<code>UPDATE</code>类似，<code>DELETE</code>语句也可以一次删除多条记录：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id<span class="operator">&gt;=</span><span class="number">5</span> <span class="keyword">AND</span> id<span class="operator">&lt;=</span><span class="number">7</span>;</span><br><span class="line"><span class="comment">-- 查询并观察结果:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多模特征结合的火灾检测系统开发</title>
      <link href="2021/07/14/Projects_Me/%E5%A4%9A%E6%A8%A1%E7%89%B9%E5%BE%81%E7%BB%93%E5%90%88%E7%9A%84%E7%81%AB%E7%81%BE%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
      <url>2021/07/14/Projects_Me/%E5%A4%9A%E6%A8%A1%E7%89%B9%E5%BE%81%E7%BB%93%E5%90%88%E7%9A%84%E7%81%AB%E7%81%BE%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>最近，基于前段时间西昌的森林发生火灾，不仅对当地的居民，环境和森林动物都造成了极大的影响，还对我国人力和物力造成损失。我们团队思考着能不能用到一些智能化的手段，能够在火势刚刚兴起的时候，能够检测并且通过互联网(或者其他的手段)实现预警。对于市场目前的调研来说，目前都是使用烟雾报警器，或者红外技术监测。但是目前深度学习技术驱动下的计算机视觉快速发展，我们就不能考虑到能够通过摄像头实现火灾，烟雾的检测？基于此，想到了利用目标检测来解决火焰检测的问题。通过烟雾传感器，红外传感设备的辅助作用下，实现这么一个森林火灾预警系统的设计。</p><span id="more"></span><h2 id="设计框图"><a href="#设计框图" class="headerlink" title="设计框图"></a>设计框图</h2><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210716120633.png" alt="image-20210716120632813"></p><h2 id="整理数据集和训练模型"><a href="#整理数据集和训练模型" class="headerlink" title="整理数据集和训练模型"></a>整理数据集和训练模型</h2><p>首先，要先搜集好数据集，这个项目中要应用的数据集是火灾相关的数据图片，感谢社区朋友的开源支持，我拿到了1w未标注和2千张已标注的数据集，已标注的数据集只实现了火的分类，我认为太少了，就找团队的朋友帮我标了三千张，分类是：fire，smoke，person。下面介绍细节：</p><h3 id="1-整理数据集"><a href="#1-整理数据集" class="headerlink" title="1.整理数据集"></a>1.整理数据集</h3><p>我们将3000张图片整理成了coco数据集类型，我将标注好的数据集分成以下目录结构：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">----fire_detect</span><br><span class="line"> |---images</span><br><span class="line">   |---train</span><br><span class="line">   |---test</span><br><span class="line"> |---labels</span><br><span class="line">   |---train</span><br><span class="line">   |---test</span><br></pre></td></tr></tbody></table></figure><p>train和test目录下放的就是训练集2400张和测试集600张。整理好了上传给服务器。</p><h3 id="2-训练模型"><a href="#2-训练模型" class="headerlink" title="2.训练模型"></a>2.训练模型</h3><p>首先，把yolov5从仓库git下来：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ultralytics/yolov5.git</span><br><span class="line">cd yolov5</span><br><span class="line">cd data</span><br></pre></td></tr></tbody></table></figure><p>然后建立一个<code>fire_det.yaml</code></p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210715095029.png" alt="image-20210715095029642"></p><p>准备工作就已经做好了，运行以下目录训练：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd .. //将目录路径改在yolov5下面</span><br><span class="line">python3 train.py --img 640 --batch 16 --epochs 300 --data fire_det.yaml --weights yolov5s.pt  //训练</span><br><span class="line">python3 detect.py --source ../fire_dataset/fire_detect.mp4 --weights runs/train/exp__/weights/best.pt --conf 0.25  //测试模型</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="将模型部署到Jetson"><a href="#将模型部署到Jetson" class="headerlink" title="将模型部署到Jetson"></a>将模型部署到Jetson</h2><p>我们要启用Jetson Nano上面的的tensorrt进行加速，需要得到能够供tensorrt推理的模型文件（.engine）。然后我们使用的是<strong>.pt -&gt; .wts -&gt; .engine</strong>的路线来生成，下面将记录一下过程：</p><h3 id="1-利用-pt生成-wts文件"><a href="#1-利用-pt生成-wts文件" class="headerlink" title="1.利用.pt生成.wts文件"></a>1.利用.pt生成.wts文件</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v5.0 https://github.com/ultralytics/yolov5.git</span><br><span class="line">git clone https://github.com/wang-xinyu/tensorrtx.git</span><br><span class="line">cp {tensorrtx}/yolov5/gen_wts.py {ultralytics}/yolov5</span><br><span class="line">cd {ultralytics}/yolov5</span><br><span class="line">python gen_wts.py yolov5s.pt</span><br></pre></td></tr></tbody></table></figure><h3 id="2-编译和运行-yolov5"><a href="#2-编译和运行-yolov5" class="headerlink" title="2.编译和运行./yolov5"></a>2.编译和运行./yolov5</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd {tensorrtx}/yolov5/</span><br><span class="line">// 对于自定义的数据集，需要修改yololayer.h里面的CLASS_NUM</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cp {ultralytics}/yolov5/yolov5s.wts {tensorrtx}/yolov5/build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo ./yolov5 -s [.wts] [.engine] [s/m/l/x/s6/m6/l6/x6 or c/c6 gd gw]  // serialize model to plan file</span><br></pre></td></tr></tbody></table></figure><h3 id="3-修改yolov5-trt-py"><a href="#3-修改yolov5-trt-py" class="headerlink" title="3.修改yolov5_trt.py"></a>3.修改yolov5_trt.py</h3><p> 这个主要是对文件中的调用引擎文件的路径做修改，其他的修改我已经修改好了，所以后面对于模型更换后，只需要更改模型引擎路径就好了。修改好的yolov5_trt.py，我已经放到了到github，随时可以git下来使用。</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210715094304.png" alt="image-20210715094242836"></p><h3 id="4-最终效果"><a href="#4-最终效果" class="headerlink" title="4.最终效果"></a>4.最终效果</h3><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210715100403.png" alt="image-20210715100402754"></p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210715100416.png" alt="image-20210715100416360"></p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210715100447.png" alt="image-20210715100447503"></p><p>这个本来是能够在13fps左右完成检测，但是我打开了浏览器，降低了检测性能，只能够到10fps左右。但是对于yolov5来说，这已经是个较为满意的结果了，模型训练的工作就到此为止了，以后可能会用到其他高效的检测模型，比如nanonet等轻量化模型。</p><h2 id="Flask-Gunicorn-nginx-部署到云服务器"><a href="#Flask-Gunicorn-nginx-部署到云服务器" class="headerlink" title="Flask+Gunicorn+nginx 部署到云服务器"></a>Flask+Gunicorn+nginx 部署到云服务器</h2><p>将写好的Flask服务器的程序放在云服务器上面，但是由于flask提供的服务器不太稳定，所以使用Gunicorn容器代替flask服务器，然后我们将nginx作为http代理，将端口映射到gunicorn端口上。这样就可以通过公网ip访问了，然后通过flask建立路由。</p><p>操作命令如下:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim hello.py</span><br><span class="line">gunicorn -w 4 -b 127.0.0.1:5000 hello:app //运行</span><br><span class="line">ps aux | grep gunicorn</span><br><span class="line">kill -9 xxx //结束进程</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-七月学习计划</title>
      <link href="2021/07/13/Plans/2021_07/"/>
      <url>2021/07/13/Plans/2021_07/</url>
      
        <content type="html"><![CDATA[<p>准备电赛！准备人工智能创意赛复赛！准备洛谷刷题一天两道！准备嵌入式比赛作品！</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210415180054.gif" alt=""></p><h2 id="本月计划"><a href="#本月计划" class="headerlink" title="本月计划"></a>本月计划</h2><p><strong>必须完成部分：</strong></p><ul><li>[ ] 电赛准备恒流源，恒压源等等，spwm波可调频</li><li>[ ] 洛谷每日两题</li><li>[ ] 智慧渔政系统实现客户端和服务端的联系，图片传输</li><li>[ ] 智能加湿系统</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="2021/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>2021/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>这篇博客主要是记录一下快速排序的算法思路。掌握快排的精髓。可以说排序算法中，快速排序最最重要和实用的。所以一定要学好！</p> <span id="more"></span><h2 id="算法介绍和实现步骤"><a href="#算法介绍和实现步骤" class="headerlink" title="算法介绍和实现步骤"></a>算法介绍和实现步骤</h2><p><strong>快速排序（Quicksort）</strong>，又称 <strong>划分交换排序（partition-exchange sort）</strong> 。</p><p><strong>快速排序（Quicksort）</strong> 在平均状况下，排序 <strong>n</strong> 个项目要 <strong>O(n log n)</strong> 次比较。在最坏状况下则需要 <strong>O(n2)</strong> 次比较，但这种状况并不常见。事实上，快速排序 <strong>O(n log n)</strong> 通常明显比其他算法更快，因为它的 <strong>内部循环（inner loop）</strong> 可以在大部分的架构上很有效率地达成。</p><p>快速排序使用 <strong>分治法（Divide and conquer）</strong> 策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列。</p><p>快速排序的算法步骤如下：</p><ol><li>挑选基准值：从数列中挑出一个元素，称为 <strong>“基准”（pivot）</strong> ；</li><li>分割：重新排序序列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成；</li><li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。</li></ol><p>递归到最底部的判断条件是序列的大小是零或一，此时该数列显然已经有序。</p><p>选取基准值有数种具体方法，此选取方法对排序的时间性能有决定性影响。</p><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><p>这是快速排序的算法，这是我第一次写的算法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">position</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line"><span class="keyword">int</span> pivot, i;</span><br><span class="line"></span><br><span class="line">i = left;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=left; j&lt;right; j++){</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[right]){</span><br><span class="line"><span class="built_in">std</span>::swap(a[i], a[j]);</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">std</span>::swap(a[i], a[right]);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line"><span class="keyword">int</span> center;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right){</span><br><span class="line">center = position2(a, left, right);</span><br><span class="line">quick_sort(a, left, center<span class="number">-1</span>);</span><br><span class="line">quick_sort(a, center+<span class="number">1</span>, right);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n, m, b, flag=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">m = n;</span><br><span class="line"><span class="keyword">while</span> (n--){</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">a.push_back(b);</span><br><span class="line">}</span><br><span class="line">quick_sort(a, <span class="number">0</span>, a.size()<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++){</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后提交评测，只通过了两个指标，直接裂开<span class="github-emoji" style="display:inline;vertical-align:middle"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，然后我仔细一想，快排只是时间复杂度平均<strong>O(nlogn)</strong>, 在完全不排序的情况下时间复杂度会是<strong>O(n^2)</strong>，想到这里，我好像悟了，我这是单向排序的，对于一个较大的元素，会被交换多次，特别是完全逆向排序的情况下。所以我换成了双向快排的。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">position2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line"><span class="keyword">int</span> i = left+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>){</span><br><span class="line"><span class="keyword">while</span> (i &lt;= j &amp;&amp; a[i] &lt;= a[left]) i++;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= j &amp;&amp; a[j] &gt;= a[left]) j--;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">std</span>::swap(a[i], a[j]);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">std</span>::swap(a[j], a[left]);</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后只提升了一个指标，好像还是没有解决完全逆向排序的结果，所以我想到了先打乱，结果提交发现还是只提升了一个指标，到这里我就还差一个指标，我实在找不到问题所在了，然后下载了他的测试数据，原来他用了50w个相同的数字<span class="github-emoji" style="display:inline;vertical-align:middle"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，畜生，只有这样了，先判断是不是可以判断是不是完全相同，相同就不需要快速排序了。这样经过多次更正，就完美提交了：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">position2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line"><span class="keyword">int</span> i = left+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>){</span><br><span class="line"><span class="keyword">while</span> (i &lt;= j &amp;&amp; a[i] &lt;= a[left]) i++;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= j &amp;&amp; a[j] &gt;= a[left]) j--;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">std</span>::swap(a[i], a[j]);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">std</span>::swap(a[j], a[left]);</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line"><span class="keyword">int</span> center;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right){</span><br><span class="line">center = position2(a, left, right);</span><br><span class="line">quick_sort(a, left, center<span class="number">-1</span>);</span><br><span class="line">quick_sort(a, center+<span class="number">1</span>, right);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n, m, b, flag=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">m = n;</span><br><span class="line"><span class="keyword">while</span> (n--){</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">a.push_back(b);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">std</span>::random_shuffle(a.begin(), a.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m<span class="number">-1</span>; i++){</span><br><span class="line"><span class="keyword">if</span> (a[i] != a[i+<span class="number">1</span>]){</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (flag) quick_sort(a, <span class="number">0</span>, a.size()<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++){</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>今天刷到了洛谷的排序算法的部分的题目，是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210712185226.png" alt="image-20210712185219120"></p><p>很明显对于输入来说，m &lt;= 2000000这就表明我们必须舍弃O(n^2)的排序算法，也就是冒泡，选择，插入。这几个很简单容易理解，我不打算通过这道题来复习了。这道题我打算采用的是<strong>希尔排序</strong>。</p> <span id="more"></span><h2 id="希尔排序算法介绍"><a href="#希尔排序算法介绍" class="headerlink" title="希尔排序算法介绍"></a>希尔排序算法介绍</h2><p><strong>希尔排序</strong>，也称<strong>递减增量排序算法</strong>，是<strong>插入排序</strong> 的一种更高效的改进版本。希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ol><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到 <strong>线性排序</strong> 的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li></ol><p>步长的选择是希尔排序的重要部分。</p><p>只要最终步长为1任何步长序列都可以工作。</p><p>算法最开始以一定的步长进行排序。</p><p>然后会继续以一定步长进行排序，最终算法以步长为1进行排序。</p><p>当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。</p><p>希尔排序的算法步骤如下：</p><ol><li>分组：定义一个用来分割的步长；</li><li>按步长的长度K，对数组进行K趟排序；</li><li>不断重复上述步骤。</li></ol><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> len = a.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=len/<span class="number">2</span>; i&gt;<span class="number">1</span>; i/=<span class="number">2</span>){   <span class="comment">//确定步长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++){</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j+i, temp, preIndex; k &lt; len; k+=i){</span><br><span class="line">                temp = a[k];<span class="comment">//存放后一个元素(哨兵)</span></span><br><span class="line">                preIndex = k - i;<span class="comment">//前一个元素的下标</span></span><br><span class="line">                <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; a[preIndex]&gt;temp){</span><br><span class="line">                    a[preIndex+i] = a[preIndex];</span><br><span class="line">                    preIndex -= i;</span><br><span class="line">                }</span><br><span class="line">                a[preIndex+i] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-六月学习计划</title>
      <link href="2021/06/16/Plans/2021_06/"/>
      <url>2021/06/16/Plans/2021_06/</url>
      
        <content type="html"><![CDATA[<p>又是一个月，这个月很多事情都结束了，所以相对可以做一些自己的事情了，飞卡结束了，就要开始准备电赛了，我们现在是希望能够在电赛取得好的成绩。所以这个得好好复习一下单片机知识，把闭环做好。同时也是一个考试月，得好好的复习一下了。此外每天都要开始刷题，刷数据结构和算法题，我觉得不刷leetcode了，因为里面的题很多不太适合我，因为我的基础不牢，所以我现在选择洛谷，从基础开始，我一开始就是用的C++实现，希望也能够熟悉这门语言。还有几个目标：学C++版的OpenCV, 完成大创项目的大体框架。加油DLer！</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210415180054.gif" alt=""></p><span id="more"></span><h2 id="本月计划"><a href="#本月计划" class="headerlink" title="本月计划"></a>本月计划</h2><p><strong>必须完成部分：</strong></p><ul><li>[x] matlab simulink学习</li><li>[x] C++ opencv 学习，完成工程实践布置的任务</li><li>[x] 期末复习</li><li>[x] 洛谷至少刷完入门部分</li><li>[x] 火灾预警系统部署到Nano上面</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程实践任务-OpenCV学习</title>
      <link href="2021/06/15/Opencv/opencv-cpp/"/>
      <url>2021/06/15/Opencv/opencv-cpp/</url>
      
        <content type="html"><![CDATA[<p>作为一个<strong>DLer</strong>，尤其是做计算机视觉的人来说，基本的传统的图像处理是绕不开的。说起图像处理的库，就不得不提起<code>OpenCV</code>，<code>OpenCV</code>是一个开源的图像处理库，虽然目前已经大部分的视觉问题都是利于<code>TF</code>和<code>Pytorch</code>这两大深度学习库开发的。但是在很多预处理阶段都会对图像进行预处理，比如说图像的读取，图像增强，和图像保存大部分都是会用到OpenCV，所以学习OpenCV是十分必要的，特别的其中的图像处理的算法库，还是挺重要的。同时这也是工程实践项目的基础知识储备，趁着这个机会较系统的学习这个库。</p> <span id="more"></span><h2 id="阶段一、OpenCV介绍和安装"><a href="#阶段一、OpenCV介绍和安装" class="headerlink" title="阶段一、OpenCV介绍和安装"></a>阶段一、OpenCV介绍和安装</h2><p>这里我选择的是C++版本的OpenCV，虽然现在很多人都是选择的Python版本的。但是现在我希望能够多接触C++，提高我的C++的写读能力，同时学好C++的OpenCV，Python版本的也是很容易上手的。但是C++版本的OpenCV在安装起来就比Python的相对麻烦一点，我用惯了VsCode，所以利用Vscode的编程环境学习OpenCV。</p><p>对于OpenCV的环境的环境搭建，我是参考的这篇教程<span class="github-emoji" style="display:inline;vertical-align:middle"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>：<br><a href="https://blog.csdn.net/zhaiax672/article/details/88971248">https://blog.csdn.net/zhaiax672/article/details/88971248</a></p><p>这里提一下Python版本的OpenCV的安装方法，直接命令行输入：<code>pip install opencv-python</code></p><h2 id="阶段二、OpenCV的基本操作"><a href="#阶段二、OpenCV的基本操作" class="headerlink" title="阶段二、OpenCV的基本操作"></a>阶段二、OpenCV的基本操作</h2><h3 id="1-OpenCV进行图像的读写"><a href="#1-OpenCV进行图像的读写" class="headerlink" title="1. OpenCV进行图像的读写"></a>1. OpenCV进行图像的读写</h3><p>对图像的读写主要集中在两个函数：<code>imread()</code>和<code>imwrite()</code>上面，用法也相对简单。下面是这两个函数，对图片读取和保存的C++代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>{</span><br><span class="line">cv::Mat img = cv::imread(<span class="string">"lena.jpg"</span>, cv::IMREAD_GRAYSCALE);<span class="comment">//读取图片,以灰度图读入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (img.empty()){</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"读取图片失败！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cv::namedWindow(<span class="string">"image"</span>, <span class="number">1</span>);</span><br><span class="line">cv::imshow(<span class="string">"image"</span>, img);</span><br><span class="line">cv::waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cv::imwrite(<span class="string">"save_lena.jpg"</span>, img); <span class="comment">//保存图像</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-OpenCV读取视频和摄像头"><a href="#2-OpenCV读取视频和摄像头" class="headerlink" title="2. OpenCV读取视频和摄像头"></a>2. OpenCV读取视频和摄像头</h3><p>这一部分内容是我自己加的，老师的学习路线是没有给出的，但是对于我们之后的工程实践的项目里面这个对于视频的读取和摄像头的读取是非常必要的。视频读取，主要利用VideoCapture类下的方法打开视频并获取视频中的帧。</p><p>所以！以下给出代码：</p><p>(1). 读取视频</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cv::VideoCapture cap;</span><br><span class="line">cv::Mat frame;<span class="comment">//定义一帧图片</span></span><br><span class="line"></span><br><span class="line">frame = cap.open(<span class="string">"helmet_det.mp4"</span>);</span><br><span class="line"><span class="keyword">if</span> (!cap.isOpened()){</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"打开视频失败！"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cv::namedWindow(<span class="string">"output"</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cap.read(frame)){</span><br><span class="line">cv::imshow(<span class="string">"output"</span>, frame);</span><br><span class="line">cv::waitKey(<span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line">cap.release();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>cap.open()的参数为0时为读取摄像头：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame= cap.open(<span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><p>(2). 写视频</p><p>通过获取视频，然后通过</p><p><code>capture.get(CV_CAP_PROP_FRAME_WIDTH)</code>, <code>capture.get(CV_CAP_PROP_FRAME_HEIGHT)</code></p><p>获取当前帧的宽度和高度，创建一个VideoWriter类对象writer进行视频的写入。写入前可进行视频的简单处理。代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cv::VideoCapture cap;</span><br><span class="line">cv::Mat frame, gray;</span><br><span class="line"></span><br><span class="line">frame = cap.open(<span class="string">"helmet_det.mp4"</span>);</span><br><span class="line"><span class="keyword">if</span> (!cap.isOpened()){</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"打开视频失败！"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cv::Size size = cv::Size(cap.get(cv::CAP_PROP_FRAME_WIDTH),</span><br><span class="line"> cap.get(cv::CAP_PROP_FRAME_HEIGHT));</span><br><span class="line"><span class="function">cv::VideoWriter <span class="title">writer</span><span class="params">(<span class="string">"helmet.mp4"</span>, cv::VideoWriter::fourcc(<span class="string">'M'</span>, <span class="string">'J'</span>, <span class="string">'P'</span>, <span class="string">'G'</span>), <span class="number">10</span>, size, <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cv::namedWindow(<span class="string">"output"</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cap.read(frame)){</span><br><span class="line">cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY); <span class="comment">//转化成灰度图</span></span><br><span class="line">cv::threshold(gray, gray, <span class="number">0</span>, <span class="number">255</span>, cv::THRESH_BINARY | cv::THRESH_OTSU); <span class="comment">//阈值处理</span></span><br><span class="line">cv::cvtColor(gray, gray, cv::COLOR_GRAY2BGR);</span><br><span class="line">writer.write(gray);</span><br><span class="line">cv::imshow(<span class="string">"output"</span>, gray);</span><br><span class="line">cv::waitKey(<span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line">cv::waitKey(<span class="number">0</span>);</span><br><span class="line">cap.release();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>摄像头一样像上面处理。</p><h3 id="3-OpenCV在图像上面添加文字"><a href="#3-OpenCV在图像上面添加文字" class="headerlink" title="3.OpenCV在图像上面添加文字"></a>3.OpenCV在图像上面添加文字</h3><p>在图片上面添加文字也是很有必要的，有时候我们需要在图像上添加一些注释信息，比如说在视频中，我们可以利用添加文字的操作，标注视频的<strong>FPS</strong>信息。利用cv::putText()函数实现，具体实例如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="string">"lena.jpg"</span>;</span><br><span class="line"></span><br><span class="line">cv::Mat img = cv::imread(filename, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (img.empty()){</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"打开图片失败"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cv::Point p = cv::Point(<span class="number">50</span>, img.rows / <span class="number">2</span> - <span class="number">50</span>);</span><br><span class="line">cv::putText(img, <span class="string">"I'm Lena!"</span>, p, cv::FONT_HERSHEY_TRIPLEX, <span class="number">0.8</span>, cv::Scalar(<span class="number">255</span>,<span class="number">200</span>,<span class="number">200</span>), <span class="number">2</span>);  <span class="comment">//在此添加文字</span></span><br><span class="line">cv::imshow(<span class="string">"result"</span>, img);</span><br><span class="line">cv::imwrite(<span class="string">"lena_text.jpg"</span>, img);</span><br><span class="line">cv::waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210616193732.png" alt="image-20210616193724763"></p><h3 id="4-OpenCV获取像素值并进行修改"><a href="#4-OpenCV获取像素值并进行修改" class="headerlink" title="4.OpenCV获取像素值并进行修改"></a>4.OpenCV获取像素值并进行修改</h3><p>难免有时候我们要对一些单个的像素点做操作，所以我们会用到<code>cv::Mat img.at&lt;uchar&gt;(row, col)</code>获取某个图像坐标的像素值，我们还可以重新对他复制，下面就是我读取一张图片，并且把每个像素点都<strong>取反</strong>，实例如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>{</span><br><span class="line"><span class="keyword">int</span> height, width;</span><br><span class="line">cv::Mat img = cv::imread(<span class="string">"lena.jpg"</span>, cv::IMREAD_GRAYSCALE);<span class="comment">//读取图片,以灰度图读入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (img.empty()){</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"读取图片失败！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">height = img.rows;</span><br><span class="line">width = img.cols;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">0</span>; row &lt; height; ++row){</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col=<span class="number">0</span>; col &lt;width; ++col){</span><br><span class="line"><span class="keyword">int</span> gray = img.at&lt;uchar&gt;(row, col);</span><br><span class="line">img.at&lt;uchar&gt;(row, col) = <span class="number">255</span> - gray;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cv::namedWindow(<span class="string">"image"</span>, <span class="number">1</span>);</span><br><span class="line">cv::imshow(<span class="string">"image"</span>, img);</span><br><span class="line">cv::waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cv::imwrite(<span class="string">"save_lena.jpg"</span>, img);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210616203240.png" alt="image-20210616203239878"></p><h2 id="阶段三、OpenCV的图像处理方法"><a href="#阶段三、OpenCV的图像处理方法" class="headerlink" title="阶段三、OpenCV的图像处理方法"></a>阶段三、OpenCV的图像处理方法</h2><h3 id="1-OpenCV进行几何变换"><a href="#1-OpenCV进行几何变换" class="headerlink" title="1.OpenCV进行几何变换"></a>1.OpenCV进行几何变换</h3><p>常见的图像的几何变换有：移动，旋转，扩展缩放，仿射变换的等；</p><h4 id="扩展缩放"><a href="#扩展缩放" class="headerlink" title="扩展缩放"></a>扩展缩放</h4><p>扩展缩放只是改变图像的尺寸大小，OpenCV提供了<code>cv::resize</code>方法实现。图像的尺寸可以自己设置，可以指定缩放因子或者不同的插值方式。具体实例如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>{</span><br><span class="line">cv::Mat img = cv::imread(<span class="string">"lena.jpg"</span>, cv::IMREAD_GRAYSCALE);<span class="comment">//读取图片,以灰度图读入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (img.empty()){</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"读取图片失败！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cv::Mat outimg;</span><br><span class="line">cv::resize(img, outimg, cv::Size(img.rows * <span class="number">0.75</span>, img.cols * <span class="number">0.75</span>), <span class="number">0</span>, <span class="number">0</span>, cv::INTER_LINEAR); <span class="comment">//将图片缩放到75%</span></span><br><span class="line">cv::imshow(<span class="string">"origin image"</span>, img);</span><br><span class="line">cv::imshow(<span class="string">"out image"</span>, outimg);</span><br><span class="line">cv::waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210617185156.png" alt="image-20210617185156360"></p><h4 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h4><p>平移就是将对象换一个位置。图像的平移分为两步：首先定义好图像的平移矩阵，分别指定x方向和y方向上的平移量tx和ty，平移矩阵的形式如下：</p><script type="math/tex; mode=display">M=\left[\begin{array}{lll}1 & 0 & \mathrm{t}_{\mathrm{x}} \\0 & 1 & \mathrm{t}_{y}\end{array}\right]</script><p>具体实例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>{</span><br><span class="line">cv::Mat img = cv::imread(<span class="string">"lena.jpg"</span>);<span class="comment">//读取图片,以灰度图读入</span></span><br><span class="line">cv::Mat outimg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (img.empty()){</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"读取图片失败！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义平移矩阵</span></span><br><span class="line">cv::Mat t_mat = cv::Mat::zeros(<span class="number">2</span>, <span class="number">3</span>, CV_32FC1);</span><br><span class="line">t_mat.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">1</span>;</span><br><span class="line">t_mat.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">2</span>) = <span class="number">20</span>;<span class="comment">//水平偏移量</span></span><br><span class="line">t_mat.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">t_mat.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">2</span>) = <span class="number">10</span>;<span class="comment">//垂直偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据平移矩阵进行仿射变换</span></span><br><span class="line">cv::warpAffine(img, outimg, t_mat, img.size());</span><br><span class="line"></span><br><span class="line">cv::imshow(<span class="string">"origin image"</span>, img);</span><br><span class="line">cv::imshow(<span class="string">"out image"</span>, outimg);</span><br><span class="line">cv::waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210617191410.png" alt="image-20210617191409791"></p><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>图像的旋转具体实现分为两步：先根据旋转角度和旋转中心获取旋转矩阵；然后根据旋转矩阵进行仿射变换，即可实现任意角度和任意中心的旋转效果。旋转矩阵的形式如下：</p><script type="math/tex; mode=display">\left[\begin{array}{c}\alpha & \beta & (1-\alpha) \cdot \text { center } \cdot x-\beta \cdot \text { center. } y \\-\beta & \alpha & \beta \cdot \text { center. } x+(1-\alpha) \cdot \text { center } . y\end{array}\right]</script><p>其中：</p><script type="math/tex; mode=display">\begin{array}{l}\alpha=\operatorname{scale} \cdot \cos \theta \\\beta=\text { scale } \cdot \sin \theta\end{array}</script><p>以下为实例程序：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv){</span><br><span class="line">cv::Mat img = cv::imread("lena.jpg");//读取图片,以灰度图读入</span><br><span class="line">cv::Mat outimg;</span><br><span class="line"></span><br><span class="line">if (img.empty()){</span><br><span class="line">std::cout &lt;&lt; "读取图片失败！" &lt;&lt; std::endl;</span><br><span class="line">return -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//旋转角度</span><br><span class="line">double angle = 45;</span><br><span class="line">int len = std::max(img.cols, img.rows);</span><br><span class="line"></span><br><span class="line">//指定旋转中心</span><br><span class="line">cv::Point2f center(len/2, len/2);</span><br><span class="line">cv::Mat rot_mat = cv::getRotationMatrix2D(center, angle, 1.0);</span><br><span class="line"></span><br><span class="line">//根据旋转矩阵进行仿射变换</span><br><span class="line">cv::warpAffine(img, outimg, rot_mat, img.size());</span><br><span class="line"></span><br><span class="line">cv::imshow("origin image", img);</span><br><span class="line">cv::imshow("out image", outimg);</span><br><span class="line">cv::waitKey(0);</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210617192701.png" alt="image-20210617192701360"></p><h4 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h4><p>仿射变换是指在向量空间中进行一次线性变换(乘以一个矩阵)并加上一个平移(加上一个向量)，变换为另一个向量空间的过程。再OpenCV中利用warpAffine函数实现仿射变换，下面是<strong>cv::warpAffine函数</strong>：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void cv::warpAffine     (   InputArray      src,</span><br><span class="line">        OutputArray     dst,</span><br><span class="line">        InputArray      M,</span><br><span class="line">        Size    dsize,</span><br><span class="line">        int     flags = INTER_LINEAR,</span><br><span class="line">        int     borderMode = BORDER_CONSTANT,</span><br><span class="line">        const Scalar &amp;      borderValue = Scalar() </span><br><span class="line">    )</span><br></pre></td></tr></tbody></table></figure><p>参数解释</p><ul><li>src: 输入图像</li><li>dst: 输出图像，尺寸由dsize指定，图像类型与原图像一致</li><li>M: 2X3的变换矩阵</li><li>dsize: 指定图像输出尺寸</li><li>flags: 插值算法标识符，有默认值INTER_LINEAR，如果插值算法为WARP_INVERSE_MAP, warpAffine函数使用如下矩阵进行图像转换</li></ul><p><strong>对图像做仿射变换主要是需要做出仿射矩阵。</strong>该部分就不做示例了，要用的时候再添上。</p><h4 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h4><p>我们在拍摄图片的时候无法保证图片是正下方垂直拍摄的，所以在获取图像的时候会防止我们提取正确的图像，这里我们就需要用到了<strong>透视变换</strong>。这部分是比较重要的，因为在车牌检测的时候，我们经常不能够获得一个正常角度的图片，利用透视变换可以将倾斜的照片变成我们正常习惯的视角。</p><p>在做透视变换的主要任务是：找到原图像的角点。</p><p>主要流程：</p><ol><li>灰度处理、二值化、形态学操作形成连通区域</li><li>轮廓发现、将目标的轮廓绘制出来</li><li>在绘制的轮廓中进行直线检测</li><li>找出四条边，求出四个交点</li><li>使用透视变换函数，得到结果</li></ol><p>下面是示例代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="2-OpenCV进行形态学转换"><a href="#2-OpenCV进行形态学转换" class="headerlink" title="2.OpenCV进行形态学转换"></a>2.OpenCV进行形态学转换</h3><p>形态学操作是根据图像形状进行的简单操作。一般情况下对二值化图像进行的操作。需要输入两个参数，一个是原始图像，第二个被称为结构化元素或核，它是用来决定操作的性质的。两个基本的形态学操作是腐蚀和膨胀。他们的变体构成了开运算，闭运算，梯度等。下面会逐一介绍：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210626195419.png" alt="image-20210626195357572"></p><h4 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h4><p>就像土壤侵蚀一样，这个操作会把前景物体的边界腐蚀掉（但是前景仍然是白色）。这是怎么做到的呢？卷积核沿着图像滑动，如果与卷积核对应的原图像的所有像素值都是 1，那么中心元素就保持原来的像素值，否则就变为零。这样就会造成白色区域缩小，就是上面的 <strong>j</strong> 变瘦了。下面是代码示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cv::Mat src = cv::imread(<span class="string">"J.jpg"</span>), outimg;</span><br><span class="line">cv::namedWindow(<span class="string">"Origin"</span>, cv::WINDOW_NORMAL);</span><br><span class="line">cv::imshow(<span class="string">"Origin"</span>, src);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取自定义核</span></span><br><span class="line">cv::Mat element = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(<span class="number">9</span>, <span class="number">9</span>));</span><br><span class="line"><span class="comment">//腐蚀操作</span></span><br><span class="line">cv::erode(src, outimg, element);</span><br><span class="line">cv::namedWindow(<span class="string">"Erode"</span>, cv::WINDOW_NORMAL);</span><br><span class="line">cv::imshow(<span class="string">"Erode"</span>, outimg);</span><br><span class="line">cv::waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210626201905.png" alt="image-20210626201905595"></p><h4 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h4><p>与腐蚀相反，与卷积核对应的原图像的像素值中只要有一个是 1，中心元素的像素值就是 1。所以这个操作会增加图像中的白色区域（前景）。一般在去噪声时先用腐蚀再用膨胀。因为腐蚀在去掉白噪声的同时，也会使前景对象变小。所以我们再对他进行膨胀。这时噪声已经被去除了，不会再回来了，但是前景还在并会增加。膨胀也可以用来连接两个分开的物体。下面是示例程序：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cv::Mat src = cv::imread(<span class="string">"J.jpg"</span>), outimg;</span><br><span class="line">cv::namedWindow(<span class="string">"Origin"</span>, cv::WINDOW_NORMAL);</span><br><span class="line">cv::imshow(<span class="string">"Origin"</span>, src);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取自定义核</span></span><br><span class="line">cv::Mat element = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(<span class="number">9</span>, <span class="number">9</span>));</span><br><span class="line"><span class="comment">//膨胀操作</span></span><br><span class="line">cv::dilate(src, outimg, element);</span><br><span class="line">cv::namedWindow(<span class="string">"Erode"</span>, cv::WINDOW_NORMAL);</span><br><span class="line">cv::imshow(<span class="string">"Erode"</span>, outimg);</span><br><span class="line">cv::waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210626202519.png" alt="image-20210626202519693"></p><p>可以看出他们的差别就是换了一个api。</p><h4 id="其他形态学操作"><a href="#其他形态学操作" class="headerlink" title="其他形态学操作"></a>其他形态学操作</h4><ul><li><p>开运算：先腐蚀再膨胀，用来消除小物体</p></li><li><p>闭运算：先膨胀再腐蚀，用于排除小型黑洞</p></li><li><p>形态学梯度：就是膨胀图与俯视图之差，用于保留物体的边缘轮廓。</p></li><li><p>顶帽：原图像与开运算图之差，用于分离比邻近点亮一些的斑块。</p></li><li><p>黑帽：闭运算与原图像之差，用于分离比邻近点暗一些的斑块。</p></li></ul><p>这些掌握了基本的腐蚀和膨胀过后，这些就变得很简单，必要的时候再去查一查API使用。</p><h3 id="3-OpenCV进行图像平滑"><a href="#3-OpenCV进行图像平滑" class="headerlink" title="3.OpenCV进行图像平滑"></a>3.OpenCV进行图像平滑</h3><p>学习目标：</p><ul><li>学习使用不同的低通滤波器对图像进行模糊</li><li>使用自定义的滤波器对图像进行卷积</li></ul><h4 id="2D卷积"><a href="#2D卷积" class="headerlink" title="2D卷积"></a>2D卷积</h4><p>和一维信号一样，我们可以对二维图像信号进行低通滤波（LPF）和高通滤波（HPF）。LPF 帮助我们去除噪音，模糊图像。HPF 帮助我们找到图像的边缘。OpenCV提供了cv::filter2D对图像进行卷积操作。下面是利用平均滤波器对图像进行的滤波：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210626204909.png" alt="image-20210626204909215"></p><h4 id="平均"><a href="#平均" class="headerlink" title="平均"></a>平均</h4><p>这是由一个归一化卷积框完成的。他只是用卷积框覆盖区域所有像素的平均值来代替中心元素。可以使用函数 <strong>cv::blur()</strong> 和 <strong>cv::boxFilter()</strong> 来完这个任务。我们需要设定卷积框的宽和高。下面是一个 3x3 的归一化卷积框：</p><script type="math/tex; mode=display">K=\frac{1}{9}\left[\begin{array}{lll}1 & 1 & 1 \\1 & 1 & 1 \\1 & 1 & 1\end{array}\right]</script><p>下面是示例代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><h4 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h4><p>现在把卷积核换成高斯核（简单来说，方框不变，将原来每个方框的值是相等的，现在里面的值是符合高斯分布的，方框中心的值最大，其余方框根据距离中心元素的距离递减，构成一个高斯小山包。原来的求平均数现在变成求加权平均数，全就是方框里的值）。实现的函数是 <strong>cv::GaussianBlur()</strong>。我们需要指定高斯核的宽和高（必须是奇数）。以及高斯函数沿 X，Y 方向的标准差。如果我们只指定了 X 方向的的标准差，Y 方向也会取相同值。如果两个标准差都是 0，那么函数会根据核函数的大小自己计算。高斯滤波可以有效的从图像中去除<strong>高斯噪音</strong>。</p><p>下面是示例代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><h4 id="中值模糊"><a href="#中值模糊" class="headerlink" title="中值模糊"></a>中值模糊</h4><p>顾名思义就是用与卷积框对应像素的中值来替代中心像素的值。这个滤波器经常用来去除<strong>椒盐噪声</strong>。前面的滤波器都是用计算得到的一个新值来取代中心像素的值，而中值滤波是用<strong>中心像素周围（也可以使他本身）的值来取代他</strong>。他能有效的去除噪声。卷积核的大小也应该是一个奇数。在这个例子中，我们给原始图像加上 50% 的噪声然后再使用中值模糊。</p><p>下面是示例代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><h4 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h4><p>双边滤波在同时使用空间高斯权重和灰度值相似性高斯权重。空间高斯函数确保只有邻近区域的像素对中心点有影响，灰度值相似性高斯函数确保只有与中心像素灰度值相近的才会被用来做模糊运算。所以这种方法会<strong>确保边界不会被模糊掉</strong>，因为边界处的灰度值变化比较大。</p><p>下面是示例代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><h3 id="4-OpenCV进行边缘检测"><a href="#4-OpenCV进行边缘检测" class="headerlink" title="4.OpenCV进行边缘检测"></a>4.OpenCV进行边缘检测</h3>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yolov1-论文解读笔记</title>
      <link href="2021/05/17/Paper/yolov1/"/>
      <url>2021/05/17/Paper/yolov1/</url>
      
        <content type="html"><![CDATA[<p>涉足目标检测领域，不仅仅是在盲目的做数据集，训练，调参。而是要解读背后的算法，这样才会在能力上面有更大的提升。所以我现在开始对yolo系列的论文进行解读。这一篇是关于YOLOv1的解读，现在还不知道具体的读后感。到时候读完在结语写出吧~</p><span id="more"></span><h2 id="摘要解读"><a href="#摘要解读" class="headerlink" title="摘要解读"></a>摘要解读</h2><p>YOLO_v1 的作者提出，YOLO算法采用了一种不同与之前的目标检测的方法(之前的方式是利用的<strong>分类器</strong>来检测) —回归，这个回归问题实现空间分离的边界框和分类概率。YOLOv1的模型能以每秒45帧的速度处理图像。总之，就是YOLO实现了用回归执行检测目标，而且在推理速度得到了提升。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>YOLO将物体检测任务当做回归任务来处理，直接通过整个图片的所有像素得到bounding box的坐标，和box内的置信度和class probabilities。在YOLO中，只需要输入到神经网络就能得出图像中有哪些物体和物体的位置。</p><ul><li>这是YOLO目标检测的大致流程：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210522212508.png" alt="image-20210522212408645"></p><p><strong>YOLO的优点是</strong>：</p><ul><li>Yolo相比其他的目标检测算法来说，更加的简单，原因在于Yolo采用的是一个单一的神经网络，直接得到目标的bounding box 的位置和置信度，分类概率。</li><li>Yolo检测非常快， 由于将检测框架视为回归问题，因此不需要复杂的流程。只需要测试时在新图像上运行神经网络即可检测到结果。Yolo在Titan X GPU上，标准版本的Yolo系统可以每秒处理45张图像， Fast Yolo可以处理150帧图像。</li><li>Yolo解释了做预测时，对于图像的全局问题。相比于滑动窗口，Yolo看到的是全局的图像，当图像在做训练和测试的时候。</li><li>YOLO 学到物体更泛化的特征表示。当在自然场景图像上训练 YOLO，再在 艺术图像上去测试 YOLO 时，YOLO 的表现要优于 DPM、R-CNN。YOLO 模型更能适应新的领域，由于其是高度可推广的，即使有非法输入，它也不太可能崩溃。</li></ul><p><strong>YOLO的缺点：</strong></p><ul><li>YOLO在准确性方面仍落后于最新的检测系统。尽管它可以快速识别图像中的对象，但是在定位方面效果不太好，尤其是定位小型对象目标。</li></ul><h2 id="统一检测"><a href="#统一检测" class="headerlink" title="统一检测"></a>统一检测</h2><p>我们的系统将输入图像划分为<strong>S×S</strong>网格。如果目标对象的中心落入网格单元，则该网格单元负责检测该对象。每个网格单元预测<strong>B</strong>个边界框和这些框的置信度得分。这些置信度得分反映了该模型对这个网格包含一个对象的置信度（是否有目标对象），以及它认为网格预测的准确性。形式上，我们将<strong>置信度</strong>定义为：</p><script type="math/tex; mode=display">\operatorname{Pr}(\text { Object }) * \text { IOU }_{\text {preed }}^{\text {truth }}</script><p>Pr(Object)表示其网格单元（注意是网格单元不是边界框）内是否含有目标对象，如果该单元格中没有对象，即Pr(Object) 为0，则置信度分数应为零。否则，则表示含有目标对象，Pr(Object) 为1，置信度分数等于预测框与真实框的交并比（IOU）（数值在[0,1]之间，数值越大说明重合区域越大，得分越高）。</p><p>每个边界框由5个预测组成：x，y，w，h和置信度。 （x，y）坐标表示边界框相对于网格单元边界的中心。（w，h）相对于整个图像预测宽度和高度。最后，置信度预测表示预测框与任何地面真实框之间的IOU。</p><p>每个网格单元还预测<strong>C</strong>个条件类概率，$\operatorname{Pr}($ Class $\mid$ Object $)$ ，这些概率以包含对象的网格单元为条件。 无论预测边界框<strong>B</strong>的数量如何，都仅预测每个网格单元的一组类概率，也就是说每个网格单元预测一组类概率。</p><p>在测试时，将条件类别的概率和各个预测框的置信度相乘：</p><script type="math/tex; mode=display">\operatorname{Pr}\left(\text { Class }_{i} \mid \text { Object }\right)^{*} \operatorname{Pr}(\text { Object })^{*} I O U_{\text {pred }}^{\text {truth }}=\operatorname{Pr}\left(\text { Class }_{i}\right)^{*} \text { IOU }_{\text {pred }}^{\text {truth }}</script><p>这样既可得到每个bounding box的具体类别的confidence score。这乘积既包含了bounding box中预测的class的 probability信息，也反映了bounding box是否含有Object和bounding box坐标的准确度。（显然如果cell中不含有目标对象，则乘积直接为0）</p><p>大致流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210522222312.png" alt="image-20210522222312413"></p><p>将YOLO用于PASCAL VOC数据集时：论文使用的 S=7，即将一张图像分为7×7=49个网格每一个网格预测B=2个boxes（每个box有 x,y,w,h,confidence，5个预测值），同时C=20（PASCAL数据集中有20个类别）。因此，最后的prediction是7×7×30 { 即S <em> S </em> ( B * 5 + C) }的Tensor（张量）</p><h3 id="网络设计"><a href="#网络设计" class="headerlink" title="网络设计"></a>网络设计</h3><p>YOLO网络借鉴了GoogLeNet分类网络结构。 <strong>网络有24个卷积层，其后是2个全连接的层</strong>，不同的是，YOLO未使用inception module，而是使用1x1卷积层（此处1x1卷积层的存在是为了跨通道信息整合）+3x3卷积层简单替代。最终输出的是7x7x30的张量的预测值。具体如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210523200153.png" alt="image-20210523200153465"></p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>首先利用ImageNet 1000-class的分类任务数据集Pretrain卷积层。使用上述网络中的前20 个卷积层，加上一个 average-pooling layer，最后加一个全连接层，作为 Pretrain 的网络。训练大约一周的时间，使得在ImageNet 2012的验证数据集Top-5的精度达到 88%，这个结果跟 GoogleNet 的效果相当。</p><p>将Pretrain的结果的前20层卷积层应用到Detection中，并加入剩下的4个卷积层及2个全连接。同时为了获取更精细化的结果，将输入图像的分辨率由 224<em> 224 提升到 448</em> 448。将所有的预测结果都归一化到 0~1, 使用 Leaky RELU 作为激活函数。 Leaky RELU的公式如下：</p><script type="math/tex; mode=display">\phi(x)=\left\{\begin{array}{ll}x, & \text { if } x>0 \\0.1 x, & \text { otherwise }\end{array}\right.</script><p>Leaky RELU可以解决RELU的梯度消失问题。</p><p><strong>损失函数：</strong></p><p>在实现中，最主要的就是怎么设计损失函数，让这个三个方面得到很好的平衡。作者简单粗暴的全部采用了<strong>sum-squared error loss</strong>来做这件事。</p><p>大概就是下面这个形式，目前看不大懂，等以后再研究吧：</p><script type="math/tex; mode=display">\begin{array}{l}\lambda_{\text {coord }} \sum_{i=0}^{S^{2}} \sum_{j=0}^{B} \mathbb{1}_{i j}^{\text {obj }}\left[\left(x_{i}-\hat{x}_{i}\right)^{2}+\left(y_{i}-\hat{y}_{i}\right)^{2}\right] \\\quad+\lambda_{\text {coord }} \sum_{i=0}^{S^{2}} \sum_{j=0}^{B} \mathbb{1}_{i j}^{\text {obj }}\left[\left(\sqrt{w_{i}}-\sqrt{\hat{w}_{i}}\right)^{2}+\left(\sqrt{h_{i}}-\sqrt{\hat{h}_{i}}\right)^{2}\right] \\+\sum_{i=0}^{S^{2}} \sum_{j=0}^{B} \mathbb{1}_{i j}^{\text {obj }}\left(C_{i}-\hat{C}_{i}\right)^{2} \\+\sum_{i=0}^{S^{2}} \mathbb{1}_{i}^{\text {obj }} \sum_{c \in \text { classes }}\left(p_{i}(c)-\hat{p}_{i}(c)\right)^{2}\end{array}</script><p>中间的就是和其他的模型的比较，就不做记录了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>论文介绍一篇通用性的目标检测方法——YOLO，模型构造简单，可以直接在整个图片上训练。不想基于分类的方式，YOLO在直接对应检测性能的损失函数上训练，使整个模型联合训练。FastYOLO是文献中YOLO中最快的通用对象检测器，YOLO推动了最先进的实时目标检测。YOLO还很好地推广到新领域，使其成为依赖于快速、健壮的对象检测的应用程序。</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-五月学习计划</title>
      <link href="2021/05/07/Plans/2021_05/"/>
      <url>2021/05/07/Plans/2021_05/</url>
      
        <content type="html"><![CDATA[<p>上个月有一些没有完成的任务，主要是六级，惭愧，考了2次都没过，所以这个月一定要好好准备一下。我打算白天六级，晚上搞技术。早睡早起！</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210415180054.gif" alt=""></p><span id="more"></span><h2 id="本月计划"><a href="#本月计划" class="headerlink" title="本月计划"></a>本月计划</h2><p><strong>必须完成部分：</strong></p><ul><li>[ ] 完成六级试卷8套，每套的听力精听</li><li>[x] 完成OCR中的文字识别</li><li>[x] 智慧渔政的软著书写</li><li>[x] 跑一个yolov5的开源项目</li><li>[x] Android学习</li><li>[x] 读5篇在目标检测领域内的论文</li></ul><h2 id="6日-9日-计划"><a href="#6日-9日-计划" class="headerlink" title="6日-9日 计划"></a>6日-9日 计划</h2><ul><li>[x] 智慧渔政软著书写</li><li>[x] 完成六级试卷两套</li><li>[x] Android控件学习</li></ul><h2 id="10日-16日"><a href="#10日-16日" class="headerlink" title="10日-16日"></a>10日-16日</h2><ul><li>[ ] 完成六级试卷两套</li><li>[x] OCR功能完善提交</li><li>[x] ESP32环境搭建</li></ul><h1 id="17日-23日"><a href="#17日-23日" class="headerlink" title="17日-23日"></a>17日-23日</h1><ul><li>[x] 完成一个寝室门禁的设计完成</li><li>[x] 完成OCR的文字识别</li></ul><h1 id="23日-29日"><a href="#23日-29日" class="headerlink" title="23日-29日"></a>23日-29日</h1><ul><li>[x] 跑一个yolov5的开源项目</li><li>[x] 读论文</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyQt-利用QSS美化界面</title>
      <link href="2021/04/18/PyQt5/QSS/"/>
      <url>2021/04/18/PyQt5/QSS/</url>
      
        <content type="html"><![CDATA[<p>由于Pyqt（Qt在内）设计的界面很丑陋啊，不能够忍受，由于项目的需要，必须要对之前写的界面进行美化。其中就必须用到一个工具——<strong>QSS</strong>，QSS这东西看着网络上对它的介绍：这是一个类似于CSS语言的东西，负责对控件的美化，风格设置，<strong>如果对CSS熟悉的人，对QSS就很好入手</strong>。好了，我不会CSS，这不就是难为我了吗。然后，我就疯狂搜寻网络上的相关资料。果然发现用了QSS和没有用设计出来的界面有着天壤之别！</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210420180314.gif" alt=""></p> <span id="more"></span><h2 id="从无到有"><a href="#从无到有" class="headerlink" title="从无到有"></a>从无到有</h2><p>这里我将会从0开始设计一个属于我的一个自认为还行的界面，怎么也得比原始的Qt界面要好看吧 <span class="github-emoji" style="display:inline;vertical-align:middle"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 。这个过程也记录下来，方便以后回顾。</p><p>我所用到的工具：</p><ul><li>Pyqt5</li><li>Qt Designer</li><li>VsCode</li><li>Python</li></ul><p>有一说一，有了<strong>Qt Designer</strong>的帮助，界面开发时，在设计框架上面可以进程加快很多，比一行一行代码手敲效率搞了不知道多少。当然我不是很精通这个软件，过程中会遇到一些，这些问题也会记录 <span class="github-emoji" style="display:inline;vertical-align:middle"><span>📝</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4dd.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="Qt-Designer设计框架"><a href="#Qt-Designer设计框架" class="headerlink" title="Qt Designer设计框架"></a>Qt Designer设计框架</h2><p>首先第一个难点就是，<strong>布局</strong>，我一般都是用的栅格布局。但是当你把栅格布局把组件布局好过后，但是里面的组件就会变得不受控制。所以就有两个点，需要用在布局上面：弹簧(<strong>Spacers)</strong>和属性<strong>Layout</strong>，这两个部分一定要好好的调，不然就会很难受，这里建议就是耐心一点，慢慢试试参数。</p><p>下面是利用Qt Designer设计的界面骨架，这就是一个图形界面最初的样子 <span class="github-emoji" style="display:inline;vertical-align:middle"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> </p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210422161722.png" alt="image-20210422161715303"></p><h2 id="利用QSS对界面进行装修"><a href="#利用QSS对界面进行装修" class="headerlink" title="利用QSS对界面进行装修"></a>利用QSS对界面进行装修</h2><p>用<code>qt designer</code> 设计好的界面，选择另存为可以保存为<code>.ui</code>文件，这样的文件我们是不能够直接使用的，所以我们还需要运行命令，将<code>.ui</code>文件转化为<code>.py</code>文件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyuic5 -x xxx.ui -o xxx.py</span><br></pre></td></tr></tbody></table></figure><p>这样在相同的目录下就会产生生成的GUI的py文件，你可以<strong>python</strong>它一下，可以得到和你设计的一样的界面。此后就可以对该py文件进行修改，对相应的组件进行<strong>QSS</strong>装修。</p><p>下面是我对一些组件美化的qss:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">self.widget.setStyleSheet(<span class="string">'''</span></span><br><span class="line"><span class="string">                                        QWidget#widget{</span></span><br><span class="line"><span class="string">                                            color:#232C51;</span></span><br><span class="line"><span class="string">                                            background:white;</span></span><br><span class="line"><span class="string">                                            border-top:1px solid darkGray;</span></span><br><span class="line"><span class="string">                                            border-bottom:1px solid darkGray;</span></span><br><span class="line"><span class="string">                                            border-right:1px solid darkGray;</span></span><br><span class="line"><span class="string">                                        }</span></span><br><span class="line"><span class="string">                                    '''</span>) </span><br><span class="line">self.label_4.setStyleSheet(<span class="string">'''QLabel#label_4{</span></span><br><span class="line"><span class="string">                                            border:none;</span></span><br><span class="line"><span class="string">                                            font-size:25px;</span></span><br><span class="line"><span class="string">                                            font-weight:700;</span></span><br><span class="line"><span class="string">                                           font-family: "宋体";</span></span><br><span class="line"><span class="string">                                        }'''</span>)</span><br><span class="line">self.frame_2.setStyleSheet(<span class="string">'''QFrame#frame_2{</span></span><br><span class="line"><span class="string">                                            color:#232C51;</span></span><br><span class="line"><span class="string">                                            background:white;</span></span><br><span class="line"><span class="string">                                            border-top:1px solid darkGray;</span></span><br><span class="line"><span class="string">                                            border-bottom:1px solid darkGray;</span></span><br><span class="line"><span class="string">                                            border-right:1px solid darkGray;</span></span><br><span class="line"><span class="string">                                            border-left:1px solid darkGray;</span></span><br><span class="line"><span class="string">                                            border-top-right-radius:10px;</span></span><br><span class="line"><span class="string">                                            border-bottom-right-radius:10px; </span></span><br><span class="line"><span class="string">                                            border-top-left-radius:10px;</span></span><br><span class="line"><span class="string">                                            border-bottom-left-radius:10px; </span></span><br><span class="line"><span class="string">                                        }'''</span>)</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>大致QSS的基本设定，我就会color，background，border-xxx，这些基本的熟悉</p><h3 id="设置按钮的颜色和图标"><a href="#设置按钮的颜色和图标" class="headerlink" title="设置按钮的颜色和图标"></a>设置按钮的颜色和图标</h3><p>我想的是禁用了边框，因为边框的存在和我们的界面美化后显得很不一致。所以我们需要自定义关闭，最大化，最小化按钮，这里用的mac风格，分别用不同的颜色填充。修改代码为：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210422163112.png" alt="image-20210422163112349"></p><p>设置图标，我们需要用到<strong>qtawesome</strong>这个图标库，里面有许多的常用的图标。下面是他的使用方法：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210422163529.png" alt="image-20210422163529044"></p><p>选择图标就是：<code>qta.icon('fa.xxx', color)</code> ，其中的<code>fa.xxx</code>怎么选择，这里就需要打开网站：<a href="http://www.fontawesome.com.cn/faicons/">http://www.fontawesome.com.cn/faicons/</a> 里面有他的名字，直接填上xxx位置就好了，至于<code>color</code>, 就是设置图标颜色</p><h2 id="关闭窗口，拖拽等操作"><a href="#关闭窗口，拖拽等操作" class="headerlink" title="关闭窗口，拖拽等操作"></a>关闭窗口，拖拽等操作</h2><p>在此之前我们要设置几行代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MainWindow.setWindowOpacity(<span class="number">0.95</span>) <span class="comment"># 设置窗口透明度</span></span><br><span class="line">MainWindow.setWindowFlag(QtCore.Qt.FramelessWindowHint) <span class="comment"># 隐藏边框</span></span><br><span class="line">MainWindow.setAttribute(QtCore.Qt.WA_TranslucentBackground) <span class="comment"># 设置窗口背景透明</span></span><br></pre></td></tr></tbody></table></figure><p>然后重新对按钮进行信号赋值：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">self.pushButton_2.clicked.connect(self.close)</span><br><span class="line">self.pushButton_6.clicked.connect(self.slot_max_or_recv)</span><br><span class="line">self.pushButton.clicked.connect(self.showMinimized)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slot_max_or_recv</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.isMaximized():</span><br><span class="line">            self.showNormal()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.showMaximized()</span><br></pre></td></tr></tbody></table></figure><p>这样就完成了，那三个键的功能。</p><p>拖拽功能也是在页面类里面重写3个函数：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重写三个方法使我们的窗口支持拖动，上面参数 window 就是拖动对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mousePressEvent</span>(<span class="params">self, event</span>):</span>  <span class="comment"># 鼠标长按事件</span></span><br><span class="line">        <span class="keyword">if</span> event.button() == QtCore.Qt.LeftButton:</span><br><span class="line">            self.m_drag = <span class="literal">True</span></span><br><span class="line">            self.m_DragPosition = event.globalPos() - self.pos()</span><br><span class="line">            event.accept()</span><br><span class="line">            self.setCursor(QtGui.QCursor(QtCore.Qt.OpenHandCursor))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mouseMoveEvent</span>(<span class="params">self, QMouseEvent</span>):</span>  <span class="comment"># 鼠标移动事件</span></span><br><span class="line">        <span class="keyword">if</span> QtCore.Qt.LeftButton <span class="keyword">and</span> self.m_drag:</span><br><span class="line">            self.move(QMouseEvent.globalPos() - self.m_DragPosition)</span><br><span class="line">            QMouseEvent.accept()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mouseReleaseEvent</span>(<span class="params">self, QMouseEvent</span>):</span>  <span class="comment"># 鼠标释放事件</span></span><br><span class="line">        self.m_drag = <span class="literal">False</span></span><br><span class="line">        self.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))</span><br></pre></td></tr></tbody></table></figure><p>到此，我们的界面大致就设计好了！加上我们一个项目功能看看效果吧：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210422165947.png" alt="image-20210422165946783"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[PyQT5速成教程-4 Qt Designer实战[上]]: <a href="https://www.jianshu.com/p/61cb5ed4548f">https://www.jianshu.com/p/61cb5ed4548f</a></p>]]></content>
      
      
      <categories>
          
          <category> 界面设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyQt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-四月学习计划</title>
      <link href="2021/04/15/Plans/2021_04/"/>
      <url>2021/04/15/Plans/2021_04/</url>
      
        <content type="html"><![CDATA[<p>最近感觉有种目标不够坚定的样子，经常感觉事情很多，又不知道要先干啥的样子。所以特定地设置一下四月份的目标，并且上传到博客，每次打开博客都能够一眼看到，也算明确一下目标吧！</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210415180054.gif" alt=""></p><span id="more"></span><h2 id="本月计划"><a href="#本月计划" class="headerlink" title="本月计划"></a>本月计划</h2><p><strong>必须完成部分：</strong></p><ul><li>[x] 完成专业作业</li><li>[ ] 完成六级试卷4套，每套的听力精听</li><li>[x] 完成OCR中的检测</li><li>[x] 智慧渔政的GUI美化问题</li><li>[x] 飞卡智能车的AI部分实现和调优</li></ul><p><strong>拟完成部分：</strong></p><ul><li>[ ] Android 学习 (控件)</li></ul><h2 id="12日-18日-计划"><a href="#12日-18日-计划" class="headerlink" title="12日-18日 计划"></a>12日-18日 计划</h2><ul><li>[x] 完成信号与系统的作业和博客</li><li>[ ] 完成六级试卷一套</li><li>[x] OCR GUI美化  QSS</li></ul><h2 id="19日-25日-计划"><a href="#19日-25日-计划" class="headerlink" title="19日-25日 计划"></a>19日-25日 计划</h2><ul><li>[x] 完成OCR中的检测</li><li>[x] 智慧渔政的GUI美化问题</li><li>[ ] 完成一套六级真题</li><li>[x] 跑起来飞卡的AI数据    </li><li>[x] 利用Pytorch进行基于SRResNet的图片超分辨率实现</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo next主题解决无法显示Latex数学公式</title>
      <link href="2021/04/13/Blog/%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BALatex%E5%85%AC%E5%BC%8F/"/>
      <url>2021/04/13/Blog/%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BALatex%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>最近想写一遍关于傅里叶变换的文章，但是我发现<strong>Hexo</strong> <strong>Next</strong>主题下无法对<strong>Latex</strong>数学公式进行渲染，这个就让我显得很苦恼，因为数学公式实在是太多了，说明这类问题不用公式又不好理解，所以一定要解决这种问题。后来我通过百度发现了<strong>原因</strong>：</p><blockquote><p>Hexo 默认使用 <code>hexo-renderer-marked</code> 引擎渲染网页，该引擎会把一些特殊的 <code>markdown</code> 符号转换为相应的 <code>html</code> 标签，比如在 <code>markdown</code> 语法中，下划线<code>_</code>代表斜体，会被渲染引擎处理为<code>&lt;em&gt;</code>标签。</p><p>因为类 <code>Latex</code> 格式书写的数学公式下划线<code>_</code>表示下标，有特殊的含义，如果被强制转换为<code>&lt;em&gt;</code>标签，那么 <code>MathJax</code> 引擎在渲染数学公式的时候就会出错。</p><p>类似的语义冲突的符号还包括<code>*, {, }, \\</code>等。</p></blockquote><span id="more"></span><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>更换 Hexo 的 markdown 渲染引擎，hexo-renderer-kramed 引擎是在默认的渲染引擎 hexo-renderer-marked 的基础上修改了一些 bug ，两者比较接近，也比较轻量级。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></tbody></table></figure><p>执行上面的命令即可，先卸载原来的渲染引擎，再安装新的。<br>然后，跟换引擎后行间公式可以正确渲染了，但是这样还没有完全解决问题，行内公式的渲染还是有问题，因为 <code>hexo-renderer-kramed</code> 引擎也有语义冲突的问题。接下来到博客根目录下，找到<code>node_modules\kramed\lib\rules\inline.js</code>，把第11行的 escape 变量的值做相应的修改：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//escape: /^\\([\\`*{}\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br></pre></td></tr></tbody></table></figure><p>这一步是在原基础上取消了对<code>\,{,}</code>的转义(escape)。<br>同时把第20行的em变量也要做相应的修改。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></tbody></table></figure><p>重新启动hexo（先clean再generate）,问题完美解决。哦，如果不幸还没解决的话，看看是不是还需要在使用的主题中配置<strong>mathjax</strong>开关。</p><h3 id="在-Next-主题中开启-MathJax-开关"><a href="#在-Next-主题中开启-MathJax-开关" class="headerlink" title="在 Next 主题中开启 MathJax 开关"></a>在 Next 主题中开启 MathJax 开关</h3><p>如果使用了主题，别忘了在主题（Theme）中开启 MathJax 开关，下面以 next 主题为例，介绍下如何打开 MathJax 开关。</p><p>进入到主题目录，找到 _config.yml 配置问题，把 math 默认的 false 修改为true，具体如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Math Equations Render Support</span><br><span class="line">math:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Default(true) will load mathjax/katex script on demand</span><br><span class="line">  # That is it only render those page who has 'mathjax: true' in Front Matter.</span><br><span class="line">  # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line"></span><br><span class="line">  engine: mathjax</span><br><span class="line">  #engine: katex</span><br></pre></td></tr></tbody></table></figure><p>还需要在文章的Front-matter里打开mathjax开关，如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: index.html</span><br><span class="line">date: 2018-07-05 12:01:30</span><br><span class="line">tags:</span><br><span class="line">mathjax: true</span><br><span class="line">--</span><br></pre></td></tr></tbody></table></figure><p>之所以<strong>要在文章头里设置开关</strong>，是因为考虑只有在用到公式的页面才加载 Mathjax，这样不需要渲染数学公式的页面的访问速度就不会受到影响了。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号与系统——傅里叶级数和傅里叶变换基本要点</title>
      <link href="2021/04/12/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
      <url>2021/04/12/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>最近学到了信号与系统最难的部分，也是十分重要的一个部分，不管在哪个领域，学好<strong>信号与系统</strong>都是十分有必要且有帮助的。同时在信号与系统这门课里面最核心的部分之一就是<strong>傅里叶变换</strong>。傅里叶变换是傅里叶一项伟大的成就。到目前，许多领域都还在使用傅里叶变换对信号进行处理，傅里叶给出了信号在<strong>时域</strong>和<strong>频域</strong>进行变换。为后面用到的信号处理技术，提供了基础。下面记录了一些对于傅里叶级数和傅里叶变换的基本公式和常用的计算方法，方便以后复习使用。</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210416135516.jpeg" alt="" style="zoom:25%;"></p><span id="more"></span><h2 id="正交函数集的概念"><a href="#正交函数集的概念" class="headerlink" title="正交函数集的概念"></a>正交函数集的概念</h2><p>为了方便对信号进行分析，常常将复杂的信号分解为基本信号的线性组合。目前的信号基本上都是在正交函数集的基础上面进行分解。</p><blockquote><p>对于函数集 $\left\{f_{n}(t), n=1,2, \cdots\right\}$，如果</p><script type="math/tex; mode=display">\int_{A_{1}}^{A_{2}} f_{n_{1}}(t) f_{n_{2}}^{*}(t) \mathrm{d} t=0, n_{1}, n_{2}=1,2,3, \cdots</script><p>且 $n_{1} \neq n_{2}$，则称此函数集称为$\left[\begin{array}{ll}A_{1} , A_{2}\end{array}\right]$上的<strong>正交函数集</strong>。</p></blockquote><p> 在<strong>实变函数域</strong>，常见的有三角形式的正交函数集：</p><script type="math/tex; mode=display">\left\{1, \sin n \omega_{0} t, \cos n \omega_{0} t, n=1,2, \cdots\right\}</script><p>在<strong>复变函数域</strong>，常见的有复指数形式正交函数集：</p><script type="math/tex; mode=display">\left\{\mathrm{e}^{\mathrm{j} n \omega_{0}{t}}, n=\pm 1, \pm 2, \cdots\right\}</script><p>对于三角正交函数集或复指数正交函数集，在正交区间$\left(t_{0}, t_{0}+T\right)$内，以下等式成立：</p><script type="math/tex; mode=display">\int_{t_{0}}^{t_{0}+T} \cos n \omega_{0} t \cdot \cos m \omega_{0} t \mathrm{~d} t=\left\{\begin{array}{ll}0 & (m \neq n) \\\frac{T}{2} & (m=n)\end{array}\right.</script><script type="math/tex; mode=display">\int_{t_{0}}^{t_{0}+T} \sin n \omega_{0} t \cdot \sin m \omega_{0} t \mathrm{~d} t=\left\{\begin{array}{ll}0 & (m \neq n) \\\frac{T}{2} & (m=n)\end{array}\right.</script><script type="math/tex; mode=display">\int_{t_{0}}^{t_{0}+T} \cos n \omega_{0} t \cdot \sin m \omega_{0} t d t=0</script><script type="math/tex; mode=display">\int_{t_{0}}^{t_{0}+T} \mathrm{e}^{\mathrm{j} n \omega_{0} t} \cdot\left(\mathrm{e}^{\mathrm{j} m \omega_{0} t}\right)^{*} \mathrm{~d} t=\left\{\begin{array}{ll}0 & (m \neq n) \\T & (m=n)\end{array}\right.</script><p>式中 $T=2 \pi / \omega_{0}$ 为函数 $\sin \omega_{0} t, \cos \omega_{0} t$ 或 $\mathrm{e}^{\mathrm{j} \omega_{0} t}$ 的周期。</p><blockquote><p>注意：</p><p>在三角正交函数集中，当 $n=0$ 时，$\cos 0=1, \sin 0=0$，而 0 不应该计在此正交函数集中，故三角正交函数集可具体写为：</p><script type="math/tex; mode=display">\left\{1, \sin \omega_{0} t, \sin 2 \omega_{0} t, \cdots, \cos \omega_{0} t, \cos 2 \omega_{0} t, \cdots\right\}</script></blockquote><h2 id="三角形式傅里叶级数"><a href="#三角形式傅里叶级数" class="headerlink" title="三角形式傅里叶级数"></a>三角形式傅里叶级数</h2><p>将任意一个周期信号在三角函数或复指数函数组成的完备正交函数集分解得到的级数,统称为傅里叶级数(Fourier Series, FS)。它们具有如下一些显著优点：</p><ol><li>三角函数和复指数函数是自然界中最常见,最基本的函数</li><li><strong>三角函数和复指数函数是简谐函数,用它们表示时间信号,自然地建立起了时间和频率这两个基本物理量间的联系</strong></li><li>简谐信号较其他信号更容易产生和处理</li><li>三角信号或复指数信号通过线性时不变系统后,仍为三角函数和复指数函数,其频率不变,只是幅度和相位产生变化,同时,线性时不变系统对三角函数或复指数函数的响应求解非常方便</li><li>许多系统(例如滤波器、信息传输系统等)的特性主要由其<strong>频域特性</strong>来描述,因此常常需要关心的并不是这些系统的冲激响应，而是其冲激响应所对应的频率特性</li><li><strong>时域中的卷积运算在频域中会转化为乘积运算</strong>,从而找到了计算卷和的-种新方永时域中难于实现的卷积求解便于实现。</li></ol><h3 id="周期信号的傅里叶级数"><a href="#周期信号的傅里叶级数" class="headerlink" title="周期信号的傅里叶级数"></a>周期信号的傅里叶级数</h3><p>如果一个信号是周期信号，则有：</p><script type="math/tex; mode=display">{f(t)=\tilde{f}(t+m T)} \quad m=0, \pm 1, \pm 2, \cdots</script><p>傅里叶提出：任何的周期信号都可以分解为正弦和余弦分量的叠加。所以，周期信号可以展开为如下形式：</p><script type="math/tex; mode=display">\tilde{f}(t)=\frac{a_{0}}{2}+\sum_{n=1}^{\infty} a_{n} \cos n \omega_{0} t+\sum_{n=1}^{\infty} b_{n} \sin n \omega_{0} t</script><p>其实就是把函数 $\tilde{f}(t)$，展开成为正交函数集 $\left\{\sin n \omega_{0} t, \cos n \omega_{0} t, n=0,1,2, \cdots\right\}$ 中函数的线性叠加。其中 <strong>$\omega_{0}$</strong> 称为<strong>基波角频率</strong>：</p><script type="math/tex; mode=display">\omega_{0}=\frac{2 \pi}{T}</script><p>对于上面的展开式中，其中的系数我们可以通过计算得到：</p><script type="math/tex; mode=display">a_{0}=\frac{2}{T} \int_{t_{0}}^{t_{0}+T} \tilde{f}(t) \mathrm{d} t</script><script type="math/tex; mode=display">a_{n}=\frac{2}{T} \int_{t_{0}}^{t_{0}+T} \tilde{f}(t) \cos n \omega_{0} t \mathrm{~d} t</script><script type="math/tex; mode=display">b_{n}=\frac{2}{T} \int_{t_{0}}^{t_{0}+T} \tilde{f}(t) \sin n \omega_{0} t \mathrm{~d} t</script><p>其中，$a_{0}$ 称为直流系数， $a_{n}$ 称为余弦分量系数 ，$b_{n}$ 称为正弦分量系数。</p><p>我们还可以把同频项合并，可以得到：</p><script type="math/tex; mode=display">\tilde{f}(t)=\frac{a_{0}}{2}+\sum_{n=1}^{\infty} a_{n} \cos n \omega_{0} t+\sum_{n=1}^{\infty} b_{n} \sin n \omega_{0} t=A_{0}+\sum_{n=1}^{\infty} A_{n} {\cos \left(n \omega_{0} t+\varphi_{n}\right)}</script><p>其中：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}A_{0}=\frac{a_{0}}{2} \\A_{n}=\sqrt{a_{n}^{2}+b_{n}^{2}} \\\varphi_{n}=-\arctan \left(\frac{b_{n}}{a_{n}}\right)\end{array}\right.</script><script type="math/tex; mode=display">\left\{\begin{array}{l}a_{n}=A_{n} \cos \varphi_{n} \\b_{n}=-A_{n} \sin \varphi_{n}\end{array}\right.</script><blockquote><p>需要注意的是,并非所有的周期信号都可以展开成三角形式傅里叶级数。信号能进行三角形式傅里叶级数展开的条件为:周期信号 $\tilde{f}(t)$ 在一个周期内 $\left[-\frac{T}{2}, \frac{T}{2}\right)$ 满足以下两个条件,称为<strong>狄里赫利(Dirichlet)</strong>条件。</p><ol><li><p>处处连续或至多有有限个第一类间断点</p></li><li><p>至多有有限多个极值点。</p></li></ol></blockquote><h2 id="指数形式的傅里叶级数"><a href="#指数形式的傅里叶级数" class="headerlink" title="指数形式的傅里叶级数"></a>指数形式的傅里叶级数</h2><p>周期信号除了可以展开为三角形式的傅里叶级数外，在满足狄里赫利条件的情况下，还可以分解为如下形式：</p><script type="math/tex; mode=display">\tilde{f}(t)=\sum_{n=-\infty}^{\infty} F_{n} \mathrm{e}^{\mathrm{j} n \omega_{0} t}</script><p>其中 <strong>$\omega_{0}$</strong> 仍然称为<strong>基波角频率</strong>。</p><h3 id="指数形式傅里叶级数的系数确定"><a href="#指数形式傅里叶级数的系数确定" class="headerlink" title="指数形式傅里叶级数的系数确定"></a>指数形式傅里叶级数的系数确定</h3><p>周期信号的傅里叶级数对可以完整地表示成：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\tilde{f}(t)=\sum_{n=-\infty}^{\infty} F_{n} \mathrm{e}^{\mathrm{jn} \omega_{0} t} \\ F_{n}=\frac{1}{T} \int_{0}^{T} \tilde{f}(t) \mathrm{e}^{-\mathrm{j} n \omega_{0} t} \mathrm{~d} t \end{array}\right.</script><p>$F_{n}$ 通常称为 $\tilde{f}(t)$ 的复指数形式<strong>傅里叶级数</strong>或<strong>频谱级数</strong>。</p><h2 id="连续时间信号的傅里叶变换"><a href="#连续时间信号的傅里叶变换" class="headerlink" title="连续时间信号的傅里叶变换"></a>连续时间信号的傅里叶变换</h2><p>除周期信号外，自然界及各种工程技术领域中还广泛地存在许多非周期信号。非周期信号，就是周期信号的周期趋近于无穷大时，周期信号转化为非周期信号，但其对于频谱的谱线间隙 $\omega_{0} = \frac{2 \pi}{T}$ 趋近于无穷小，即离散频谱转变成了连续频谱。所以研究非周期信号的连续时间信号的傅里叶变换也是非常有必要的。</p><p>为此给出傅里叶变换对，即傅里叶正变换和逆变换：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}F(j \omega)=\int_{-\infty}^{\infty} f(t) \mathrm{e}^{-\mathrm{j} \omega t} \mathrm{~d} t\\ f(t)=\frac{1}{2 \pi} \int_{-\infty}^{\infty} F(j \omega) \mathrm{e}^{\mathrm{j} \omega t} \mathrm{~d} \omega \end{array}\right.</script><p>$F(j\omega)$ 称为 $f(t)$ 的<strong>频率密度函数</strong>或简称<strong>频谱函数</strong></p><p>根据频谱函数的定义及欧拉公式可得：</p><script type="math/tex; mode=display">F(j \omega) = \int_{-\infty}^{\infty}f(t)\mathrm{e}^{-\mathrm{j} \omega t} \mathrm{~d}t \\= \int_{-\infty}^{\infty} f(t)cos\omega t \mathrm{~d}t - j\int_{-\infty}^{\infty} f(t)sin\omega t \mathrm{~d}t \\=\mathrm{~R}(\omega) +j\mathrm{X}(\omega) \\= |F(j \omega)| \mathrm{e}^{j \varphi(\omega)}</script><p>由上面的式子可以得到以下关系：</p><script type="math/tex; mode=display">\left.\begin{array}{l}|F(\mathrm{j} \omega)|=\sqrt{R^{2}(\omega)+X^{2}(\omega)} \\\varphi(\omega)=\arctan \frac{X(\omega)}{R(\omega)} \\R(\omega)=|F(\mathrm{j} \omega)| \cos \varphi(\omega) \\X(\omega)=|F(\mathrm{j} \omega)| \sin \varphi(\omega)\end{array}\right\} \quad \begin{array}{l}\end{array}</script><p>$|F(\mathrm{j} \omega)|$ 关于 $ \omega $ 的 图像称为 <strong>幅度谱</strong>， $\varphi(\omega)$ 关于 $ \omega $ 的 图像称为 <strong>相位谱</strong></p><h3 id="常用的傅里叶变换对"><a href="#常用的傅里叶变换对" class="headerlink" title="常用的傅里叶变换对"></a>常用的傅里叶变换对</h3><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th>$f(t)$</th><th>$F(\mathrm{j} \omega)$</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td>$g_{\tau}(t)$</td><td>$\tau Sa(\frac{\omega \tau}{2})$</td></tr><tr><td style="text-align:left">2</td><td>$\tau Sa(\frac{\tau t}{2})$</td><td>$2 \pi g_{\tau}(\omega)$</td></tr><tr><td style="text-align:left">3</td><td>$\mathrm{e}^{-\alpha t}u(t), \alpha &gt; 0$</td><td>$\frac{1}{a+j \omega}$</td></tr><tr><td style="text-align:left">4</td><td>$t \mathrm{e}^{-\alpha t}u(t), \alpha &gt; 0$</td><td>$\frac{1}{(a+j \omega)^2}$</td></tr><tr><td style="text-align:left">5</td><td>$\mathrm{e}^{-\alpha t}, \alpha &gt; 0 (由于博客转义问题，t为绝对值t)$</td><td>$\frac{2 \alpha}{\alpha^2+\omega^2}$</td></tr><tr><td style="text-align:left">6</td><td>$\delta(t)$</td><td>1</td></tr><tr><td style="text-align:left">7</td><td>1</td><td>$2\pi\delta(\omega)$</td></tr><tr><td style="text-align:left">8</td><td>$\delta(t - t_{0})$</td><td>$\mathrm{e}^{-j \omega t_{0}}$</td></tr><tr><td style="text-align:left">9</td><td>$cos(\omega_0 t)$</td><td>$\pi[\delta(\omega+\omega_{0})+\delta(\omega-\omega_{0})]$</td></tr><tr><td style="text-align:left">10</td><td>$sin(\omega_0 t)$</td><td>$j\pi[\delta(\omega+\omega_{0})-\delta(\omega-\omega_{0})]$</td></tr><tr><td style="text-align:left">11</td><td>$u(t)$</td><td>$\pi\delta(\omega)+\frac{1}{j\omega}$</td></tr><tr><td style="text-align:left">12</td><td>$sgn(t)$</td><td>$\frac{2}{j\omega},F(0) =0$</td></tr><tr><td style="text-align:left">13</td><td>$\frac1{\pi t}$</td><td>$-jsgn(\omega)$</td></tr><tr><td style="text-align:left">14</td><td>$\delta_{T}(t)$</td><td>$\omega_0\delta_{\omega_0}(\omega)$</td></tr><tr><td style="text-align:left">15</td><td>$\sum_{n=-\infty}^{\infty}F_{n}\mathrm{e}^{jn\omega_0 t}$</td><td>$2\pi\sum_{n=-\infty}^{\infty}F_n\delta(\omega-n\omega_0)$</td></tr><tr><td style="text-align:left">16</td><td>$\frac{t^{n-1}}{(n-1)!}\mathrm{e}^{-\alpha t}u(t), \alpha&gt;0$</td><td>$\frac{1}{(\alpha+j\omega)^n}$</td></tr></tbody></table></div><h2 id="傅里叶变换的性质与应用"><a href="#傅里叶变换的性质与应用" class="headerlink" title="傅里叶变换的性质与应用"></a>傅里叶变换的性质与应用</h2><p>傅里叶变换建立起了信号时域与频域间的联系。下面介绍傅里叶变换的性质，研究信号在时域中进行运算或变化时，在频域引起的效应。</p><h3 id="傅里叶变换的性质"><a href="#傅里叶变换的性质" class="headerlink" title="傅里叶变换的性质"></a>傅里叶变换的性质</h3><div class="table-container"><table><thead><tr><th>性质名称</th><th>时域</th><th>频域</th></tr></thead><tbody><tr><td>线性</td><td>$a_1f_1(t)+a_2f_2(t)$</td><td>$a_{1} F_{1}(j \omega)+a_{2} F_{2}(j \omega)$</td></tr><tr><td>时移</td><td>$f(t±t_0)$</td><td>$F(j \omega) \mathrm{e}^{±j \omega t_0}$</td></tr><tr><td>频移</td><td>$f(t)\mathrm{e}^{±j \omega_0t}$</td><td>$F\left[\mathrm{j}\left(\omega \mp \omega_{0}\right)\right]$</td></tr><tr><td>调制</td><td>$f(t)cosw_0t$</td><td>$\frac{1}{2}\left[F\left(j\left(\omega-\omega_{0}\right)\right)+F\left(j\left(\omega+\omega_{0}\right)\right)\right]$</td></tr><tr><td>调制</td><td>$f(t)sin\omega_0t$</td><td>$\frac{1}{2 \mathrm{j}}\left[F\left(\mathrm{j}\left(\omega-\omega_{0}\right)\right)-F\left(\mathrm{j}\left(\omega+\omega_{0}\right)\right)\right]$</td></tr><tr><td>尺度变换</td><td>$f(at)$</td><td>$\frac{1}{\mathrm{l}a\mathrm{l}} F\left(j \frac{\omega}{a}\right)$</td></tr><tr><td>对称性</td><td>$F(jt)$</td><td>$2 \pi f(-\omega)$</td></tr><tr><td>时域卷积</td><td>$f_1(t)*f_2(t)$</td><td>$F_{1}(j \omega) \cdot F_{2}(j \omega)$</td></tr><tr><td>频域卷积</td><td>$f_1(t) \cdot f_2t()$</td><td>$\frac{1}{2 \pi}\left[F_{1}(j \omega) * F_{2}(j \omega)\right]$</td></tr><tr><td>时域微分</td><td>$\frac{\mathrm{~d}^nf(t)}{\mathrm{~d}t^n}$</td><td>$(j \omega)^{n} F(j \omega)$</td></tr><tr><td>频域微分</td><td>$(-jt)^nf(t)$</td><td>$\frac{\mathrm{d}^{n} F(j \omega)}{\mathrm{d} \omega^{n}}$</td></tr><tr><td>时域积分</td><td>$\int_{-\infty}^{t} f(x) \mathrm{~d}t$</td><td>$\frac{F(j \omega)}{j \omega}+\pi F(0) \delta(\omega)$</td></tr><tr><td>频域积分</td><td><script type="math/tex">\pi f(0) \delta(t)+\frac{f(t)}{-j t}</script></td><td>$\int_{-\infty}^{\infty} F(j \eta) d \eta$</td></tr><tr><td>帕塞瓦尔定理</td><td>$\int_{-\infty}^{\infty} f^{2}(t) \mathrm{d} t$</td><td>$\frac{1}{2 \pi} \int_{-\infty}^{\infty}F(j \omega)^2\mathrm{~d}t,(其中F(j \omega)^2是F(j \omega)的绝对值的平方，也是博客转义问题)$</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 信号与系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号与系统 </tag>
            
            <tag> 傅里叶变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICDAR2019-LSVT 数据集预处理</title>
      <link href="2021/04/09/deep_learning/icdar2019/"/>
      <url>2021/04/09/deep_learning/icdar2019/</url>
      
        <content type="html"><![CDATA[<p>对于OCR要实现识别中文字符，数据集的选择是非常重要的，一定要是中文数据集。这里选择使用ICDAR2019-LSVT。因为给定的数据集，不符合<strong>PaddleOCR</strong>的train.py能够识别的格式，同时官方没有提供测试集的label，所以我们要将其进行调整：从官方给的训练集重新划分训练集和测试集，同时为其生成对应的label文件。</p><h2 id="数据集的选择"><a href="#数据集的选择" class="headerlink" title="数据集的选择"></a>数据集的选择</h2><p><strong>数据简介</strong>： ICDAR2019-LSVT共包括45w中文街景图像，包含5w（2w测试+3w训练）全标注数据（文本坐标+文本内容），40w弱标注数据（仅文本内容），如下图所示：</p> <span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210409153119.png" alt="image-20210409153118954"></p><p>这里考虑数据集太大的原因，所以只选择了全标注的数据集作为训练集和测试集。一共3w张图片。所以这里就下载了三个文件：<code>train_full_images_0.tar.gz</code>，<code>train_full_images_0.tar.gz</code>，<code>train_full_labels.json</code></p><p>数据集下载地址：<a href="https://ai.baidu.com/broad/download?dataset=lsvt">https://ai.baidu.com/broad/download?dataset=lsvt</a></p><h2 id="划分训练集和测试集"><a href="#划分训练集和测试集" class="headerlink" title="划分训练集和测试集"></a>划分训练集和测试集</h2><p>我先将下载的两个数据集合成了一个full_images，里面一共有3w张图片。现在需要做的是分成训练集和测试集比例为8：2，分别放在train_images, test_images文件夹下面。</p><p>直接贴上代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span>(<span class="params">args, images_names</span>):</span></span><br><span class="line">    origin_images_path = args.images_dir_path</span><br><span class="line">    save_train_dir_path = args.train_dir_path</span><br><span class="line">    save_test_dir_path = args.test_dir_path</span><br><span class="line"></span><br><span class="line">    rate = <span class="number">0.8</span></span><br><span class="line">    train_images = images_names[:<span class="built_in">int</span>(rate*<span class="built_in">len</span>(images_names))]</span><br><span class="line">    test_images = images_names[<span class="built_in">int</span>(rate*<span class="built_in">len</span>(images_names)):]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> train_image <span class="keyword">in</span> train_images:</span><br><span class="line">        origin_image_path = os.path.join(origin_images_path, train_image)</span><br><span class="line">        save_image_path = os.path.join(save_train_dir_path, train_image)</span><br><span class="line">        shutil.copy(origin_image_path, save_image_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> test_image <span class="keyword">in</span> test_images:</span><br><span class="line">        origin_image_path = os.path.join(origin_images_path, test_image)</span><br><span class="line">        save_image_path = os.path.join(save_test_dir_path, test_image)</span><br><span class="line">        shutil.copy(origin_image_path, save_image_path)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_images</span>(<span class="params">args</span>):</span></span><br><span class="line">    origin_images_path = args.images_dir_path</span><br><span class="line">    <span class="keyword">for</span> dirpath, dirnames, filesnames <span class="keyword">in</span> os.walk(origin_images_path):</span><br><span class="line">        print(<span class="string">"原数据集的图片数量为："</span>, <span class="built_in">len</span>(filesnames))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filesnames </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'--images_dir_path'</span>,</span><br><span class="line">                         <span class="built_in">type</span>=<span class="built_in">str</span>, </span><br><span class="line">                         default=<span class="string">'./train_data/ICDAR2019-LSVT/full_images/'</span>,</span><br><span class="line">                         <span class="built_in">help</span>=<span class="string">'原数据集的路径'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--train_dir_path'</span>,</span><br><span class="line">                         <span class="built_in">type</span>=<span class="built_in">str</span>, </span><br><span class="line">                         default=<span class="string">'./train_data/ICDAR2019-LSVT/train_images/'</span>,</span><br><span class="line">                         <span class="built_in">help</span>=<span class="string">'保存训练集的路径'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--test_dir_path'</span>,</span><br><span class="line">                         <span class="built_in">type</span>=<span class="built_in">str</span>, </span><br><span class="line">                         default=<span class="string">'./train_data/ICDAR2019-LSVT/test_images/'</span>,</span><br><span class="line">                         <span class="built_in">help</span>=<span class="string">'保存测试集的路径'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    images_names = load_images(args)</span><br><span class="line">    split(args, images_names)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><h2 id="生成对应的label"><a href="#生成对应的label" class="headerlink" title="生成对应的label"></a>生成对应的label</h2><p>训练集和测试集分好了，最后需要是生成训练集和测试集的label文件，这样才能够训练。</p><p>直接贴上代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    json_path = <span class="string">'./train_data/ICDAR2019-LSVT/full_labels.json'</span></span><br><span class="line">    test_imgs_path = <span class="string">'./train_data/ICDAR2019-LSVT/test_images/'</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(json_path, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = json.load(f)</span><br><span class="line">    train_imgs_path = <span class="string">'./train_data/ICDAR2019-LSVT/train_images/'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'./train_data/ICDAR2019-LSVT/train_label.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> fw:</span><br><span class="line">        <span class="keyword">for</span> dirpath, dirnames, images_names <span class="keyword">in</span> os.walk(train_imgs_path):</span><br><span class="line">            imgs_num = <span class="built_in">len</span>(images_names)</span><br><span class="line">            print(<span class="string">"该训练集的数量为："</span>, imgs_num)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> images_name <span class="keyword">in</span> images_names:</span><br><span class="line">            image_path = <span class="string">'train_images/'</span> + images_name</span><br><span class="line">            fname, fename = os.path.splitext(images_name)</span><br><span class="line">            image_label = image_path + <span class="string">'\t'</span> + json.dumps(data[fname]) + <span class="string">'\n'</span></span><br><span class="line">            fw.write(image_label)</span><br><span class="line">        fw.close()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'./train_data/ICDAR2019-LSVT/test_label.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> fb:</span><br><span class="line">        <span class="keyword">for</span> dirpath, dirnames, images_names <span class="keyword">in</span> os.walk(test_imgs_path):</span><br><span class="line">            imgs_num = <span class="built_in">len</span>(images_names)</span><br><span class="line">            print(<span class="string">"该测试集的数量为："</span>, imgs_num)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> images_name <span class="keyword">in</span> images_names:</span><br><span class="line">            image_path = <span class="string">'test_images/'</span> + images_name</span><br><span class="line">            fname, fename = os.path.splitext(images_name)</span><br><span class="line">            image_label = image_path + <span class="string">'\t'</span> + json.dumps(data[fname]) + <span class="string">'\n'</span></span><br><span class="line">            fb.write(image_label)</span><br><span class="line">        fb.close()</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OCR </tag>
            
            <tag> paddle </tag>
            
            <tag> 数据集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bad owner or permissions on .ssh/config Windows 10</title>
      <link href="2021/04/08/%E9%97%AE%E9%A2%98_%E8%A7%A3%E5%86%B3/ssh/"/>
      <url>2021/04/08/%E9%97%AE%E9%A2%98_%E8%A7%A3%E5%86%B3/ssh/</url>
      
        <content type="html"><![CDATA[<p>最近想尝试在vscode中用remote ssh插件尝试远程开发，可是几次没有成功，在cmd里面输入<code>ssh xx@ip</code>，提示了 <code>Bad owner or permissions on .ssh/config</code> 这个报错，就是如图中的问题:</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210408193114.png" alt="image-20210408193114481"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>找到.ssh文件夹。它通常位于C:\Users\，例如C:\Users\xxxx。</li><li>右键单击.ssh文件夹，然后单击“属性”。</li><li>找到并点击“安全”标签。<span id="more"></span></li><li>然后单击“高级”。</li><li>单击“禁用继承”，单击“确定”。</li><li>将出现警告弹出窗口。单击“从此对象中删除所有继承的权限”。</li><li>你会注意到所有用户都将被删除。让我们添加所有者。在同一窗口中，单击“编辑”按钮。</li><li>接下来，单击“添加”以显示“选择用户或组”窗口。</li><li>单击“高级”，然后单击“立即查找”按钮。应显示用户结果列表。</li><li>选择您的用户帐户。</li><li>然后单击“确定”（大约三次）以关闭所有窗口。</li></ol><p>完成所有操作后，再次关闭并打开cmd应用程序并尝试连接到远程SSH主机。现在这个问题应该解决了，同时在vscode也就可以成功连接了。</p>]]></content>
      
      
      <categories>
          
          <category> 远程开发操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 常用控件方法介绍-Android入门(一)</title>
      <link href="2021/03/27/Android/controls/"/>
      <url>2021/03/27/Android/controls/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>任何<strong>GUI</strong>的设计，入门的话，一定是控件的使用。前面学过PyQt ，有一些基本的GUI的设计思想。所以对于安卓部分的话，控件还是很容易上手的。主要是需要熟悉一下Android Studio的使用方法，以及生成的工程结构。在Android Studio里面，我们想要使用一个控件的话，是直接对XML文件进行编写，所以对于基本的XML文件的书写，要熟悉XML的语法。下面我将会介绍常用的几个Android的控件。</p><p>使用控件我们是在<code>activity_main.xml</code>里面进行编辑，这个文件是在Project结构下<code>app/src/main/res/layout/activity_main.xml</code><br> <span id="more"></span></p><h2 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h2><p>介绍控件，首先介绍方法：</p><blockquote><p>基础属性：</p><ul><li>layout_width：组件的宽度</li><li>layout_height：组件的高度</li><li>id：为TextView设置一个id号</li><li>text：设置显示的文本内容</li><li>textColor：设置字体颜色</li><li>textSize：字体大小，单位一般是用sp</li><li>textStyle：设置字体风格，三个可选值：normal， bold，italic</li><li>background：控件的背景颜色，可以理解为填充整个控件的颜色，可以是图片</li><li>gravity：设置控件中内容的对齐方向，TextView中是文件，ImageView中是图片</li></ul><p>带阴影的TextView:</p><ul><li>android:shadowColor：设置阴影颜色，需要与shadowRadius一起使用</li><li>android:shadowRadius：设置阴影的模糊程度，设为0.1就变成字体颜色了，建议使用3.0</li><li>android:shadowDx：设置阴影在水平方向的偏移，就是水平方向阴影开始的横坐标位置</li><li>android:shadowDy：设置阴影在竖直方向的偏移，就是竖直方向阴影开始的纵坐标位置</li></ul></blockquote><p>使用效果实例：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210331194049.png" alt="image-20210331194048904"></p><h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><p>按键也是控件里面重要性占比最大的，这里就介绍一下Button控件该如何使用。首先还是介绍一下常用的几个方法：</p><p><strong>StateListDrawable</strong></p><p>StateListDrawable是Drawable资源的一种，可以根据不同的状态，设置不同的图片效果，关键节点&lt; selector &gt;，我们只需要将Button的 background属性设置为该drawable资源即可轻松实现，按下按钮时不同的按钮颜色或背景。</p><blockquote><ul><li>drawable：引用的Drawable位图</li><li>state_focused：是否获取焦点</li><li>state_pressed：控件是否被按下</li><li>state_enabled：控件是否可用</li><li>state_selected：控件是否被选择，针对有滚轮的情况</li><li>state_checked：控件是否被勾选</li><li>state_checkable：控件可否被勾选，eg:checkbox</li></ul></blockquote><p><strong>Button事件处理</strong></p><ul><li>点击事件</li><li>长按事件</li><li>触摸事件</li></ul><p>使用效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210331215525.png" alt="image-20210331215525650"></p><p>其中的<code>backgroud</code>和<code>backgroundTink</code> 里面的值，分别是在drawable文件夹下面创建的selector，和在color文件夹下面的selector。</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210331220029.png" alt="image-20210331220029489"></p><p>对于按键事件的触发，是在<code>MainActivity.java</code>里面添加，下面就是MainActivity的代码示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mybutton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Miller"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        View btn = findViewById(R.id.btn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//点击事件</span></span><br><span class="line">        btn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{</span><br><span class="line">                Log.e(TAG, <span class="string">"onClick: "</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">//长按事件</span></span><br><span class="line">        btn.setOnLongClickListener(<span class="keyword">new</span> View.OnLongClickListener() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onLongClick</span><span class="params">(View v)</span> </span>{</span><br><span class="line">                Log.e(TAG, <span class="string">"onLongClick: "</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触摸事件</span></span><br><span class="line">        btn.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>{</span><br><span class="line">                Log.e(TAG, <span class="string">"onTouch: "</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h2><p>这是一个文本的输入框，也是一个必须掌握的控件。先介绍常用的方法：</p><ul><li>android:hint   输入提示</li><li>android:textColorHint  输入提示文字的颜色</li><li>android:inputType  输入类型</li><li>android:drawableXxxx  在输入框的指定方向添加图片</li><li>android:drawablePaddling  设置图片与输入内容的间距</li><li>android:paddingXxxx  设置内容与边框的间距</li><li>android:background  背景色</li></ul><p>在Android Studio里面的使用的如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210401163542.png" alt="image-20210401163542564"></p><h2 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h2><p>这是一个显示图片的控件，有时候我们需要用图片填充我们的界面，所以还是要学习一下的，他的常用方法如下：</p><ul><li>android:src 设置图片资源                                     </li><li>android:scaleType 设置图片缩放类型</li><li>android:maxHeight 最大高度</li><li>android:maxWidth 最大宽度</li><li>android:adjustViewBounds 调整View的界限</li></ul><p>值得注意的是还有图片的缩放类型：</p><ul><li>fitStart  保持宽高比缩放图片，直到较长的边与Image的边长相等，缩放完成后将图片放在ImageView的左上角</li><li>fitEnd  同上，缩放后放于右下角</li></ul><ol><li>fitXY  对图像的横纵方向进行独立缩放，使得该图片完全适应lmageView，但是图片的宽高比可能会发生改变</li><li>center 保持原图的大小，显示在lmageView的中心。当原图的size大于lmageVview的size，超过部分裁剪处理。</li><li>centerCrop 保持宽高比缩放图片，直到完全覆盖lmageView，可能会出现图片的显示不完全</li><li>centerInside  保持宽高比缩放图片，直到ImageView能够完全地显示图片</li><li>matrix 不改变原图的大小，从lmageView的左上角开始绘制原图，原图超过lmageVview的部分作裁剪处理</li></ol><p>实验示例：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210401194646.png" alt="image-20210401194646607"></p><h2 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h2><p>这是一个进度条的控件，常用的方法如下：</p><ul><li><p>android:max: 进度条的最大值</p></li><li><p>android:progress: 进度条已完成进度值</p></li><li><p>android:indeterminate: 如果设置成true,则进度条不精确显示进度</p></li><li><p>style=”?android:attr/progressBarStyleHorizontal” 水平进度条</p></li></ul><p>实践示例：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210401203614.png" alt="image-20210401203614181"></p><p>效果：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210401203650.png" alt="image-20210401203650421" style="zoom:25%;"></p><h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h2><p>这里介绍一下，通知的使用。要想使用通知组件，需要创建两个对象，一个是NotificationManager，一个是Notification。</p><ul><li>创建一个NotificationManager<br>NotificationManager类是一个<strong>通知管理器类</strong>， 这个对象是由系统维护的服务，是以单例模式的方式获得，所以一般并不直接实例化这个对象。在Activity中， 可以使用<code>Activity.getSystemService(String)</code>方法获取<strong>NotificationManager</strong>对象，Activity.getSystemService(String)方法可以通过Android系统级服务的句柄，返回对应的对象。在这里需要返回NotificationManager,所以直接传递Context.NOTIFICATION SERVICE即可 。</li><li>使用<strong>Bilder</strong>构造器来创建Notification对象<br>使用NotificationCompat类的Builder构造器来创建Notification对象，可以保证程序在所有的版本上都能正常工作。Android8.0新增了通知渠道这个概念，如果没有设置，则通知无法在Android8.0的机器上显示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210511115848.png" alt="image-20210511115839246"></p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210511120006.png" alt="image-20210511120006500"></p><h2 id="ToolBar"><a href="#ToolBar" class="headerlink" title="ToolBar"></a>ToolBar</h2><p>常用属性：</p><ul><li>android:layout_width=”match_parent”</li><li>android:layout_height=”?attr/actionBarSize”</li><li>android:background=”#ffff00”</li><li>app:navigationlcon=”@drawable/ic_baseline_arrow_back_24”</li><li>app:title=”主标题”</li><li>app:titleTextColor=”#ff0000”</li><li>app:titleMarginStart=”90dp”</li><li>app:subtitle=”子标题”</li><li>app:subtitleTextColor=”#OOffff</li><li>app:logo=”@mipmap/ic_launcher”</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210511123732.png" alt="image-20210511123726114"></p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210511123852.png" alt="image-20210511123851372"></p><h2 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h2><p>实现方式：</p><ul><li>AlertDialog.Builder builder = new AlertDialog.Builder(context);构建Dialog的各种参数</li><li>Builder.setlcon(int iconld);添加ICON</li><li>Builder.setTitle(CharSequence title);添加标题</li><li>Builder.setMessage(CharSequence message);添加消息</li><li>Builder.setView(View view);设置自定义布局</li><li>Builder.create();到建Dialog</li><li>Builder.show();显示对话框</li><li>setPositiveButton确定按钮</li><li>setNegativeButton取消按钮</li><li>setNeutralButton中间按钮</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210511133254.png" alt="image-20210511133254734"></p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210511133328.png" alt="image-20210511133327903"></p><h2 id="PopupWindow"><a href="#PopupWindow" class="headerlink" title="PopupWindow"></a>PopupWindow</h2><p>常用方法：</p><ol><li>setContentView(View contentView)：设置PopupWindow显示的View</li><li>showAsDropDown(View anchor)：相对某个控件的位置(正左下方)，无偏移</li><li>showAsDropDown(View anchor, int xoff, int yoff)：相对某个控件的位置，有偏移</li><li>setFocusable(boolean focusable)：设置是否获取焦点</li><li>setBackgroundDravIable(Drawable background)：设置背景</li><li>dismiss() ：关闭弹窗</li><li>setAnimationStyle(int animationStyle)：设置加载动画</li><li>setTouchable(boolean touchable)：设置触摸使能</li><li>setOutsideTouchable(boolean touchable)：设置PopupWindow外面的触摸使能</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210511141848.png" alt="image-20210511141847626"></p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210511141906.png" alt="image-20210511141906380"></p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210511141924.png" alt="image-20210511141923657"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三天通过计算机三级网络技术-选择题技巧</title>
      <link href="2021/03/26/computer_grade/multiple_choice_skills/"/>
      <url>2021/03/26/computer_grade/multiple_choice_skills/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>明天下午就要考计算机三级了，网络技术。。。慌得一批啊，对于计算机三级对网络技术的考察，我通过刷题的得到了许多套路的东西。这一部分就对选择题部分的重要知识点进行记录，方便以后还能够看看，当然能够帮助到别人还是不错的。</p><h2 id="RPR技术"><a href="#RPR技术" class="headerlink" title="RPR技术"></a>RPR技术</h2><ul><li>RPR和FDDI一样采用<strong>双环结构</strong><span id="more"></span></li><li>传统的 FDDI 环，当源结点向目的节点成功发送一个数据帧之后，这个数据帧由<strong>源结点</strong>从环中回收。但 <strong>RPR 环，这个数据帧由目的结点从环中回收</strong>。</li><li>RPR环能够在<strong>50ms</strong>实现自愈</li><li>RPR 环中每一个节点都执行 <strong>SRP 公平算法</strong></li><li>两个 RPR 结点间的裸光纤最大长度可达 100 公里。</li></ul><h2 id="宽带城域网"><a href="#宽带城域网" class="headerlink" title="宽带城域网"></a>宽带城域网</h2><h3 id="汇聚层"><a href="#汇聚层" class="headerlink" title="汇聚层"></a>汇聚层</h3><ul><li>汇接接入层的用户流量，进行数据分组传输的<strong>汇聚、转发与交换</strong></li><li>根据接入层的用户流量，进行本地路由、过滤、流量均衡、QoS 优先级管理，以及安全控制、IP 地址转换、流量整行等处理。</li><li>根据处理结果把用户流量转发到核心交换层或在本地进行路由处理。</li></ul><h2 id="接入技术"><a href="#接入技术" class="headerlink" title="接入技术"></a>接入技术</h2><ul><li>光纤传输系统的<strong>中继距离可达 100km</strong> 以上</li><li>Cable Modom（电缆调制解调器）利用<strong>频分复用(FDM)</strong>的方法将信道分为上行信道和下行信道</li><li>ASDL 使用一对铜双绞线，具有<strong>非对称技术特性</strong></li><li>将传输速率提高到 <strong>54Mbps</strong> 的是 <strong>802.11a 和 802.11g</strong>，<strong>802.11b</strong> 将传输速度提高到 <strong>11Mbps</strong>。</li><li>无线接入技术主要有：WLAN、WiMAX、WiFi、WMAN 和 Ad hoc等。</li><li>APON、DWDM、EPON 是光纤接入技术。</li></ul><h2 id="服务器技术"><a href="#服务器技术" class="headerlink" title="服务器技术"></a>服务器技术</h2><ul><li><strong>热插拔功能</strong>允许用户在不切断电源的情况下更换<strong>硬盘、板卡</strong>、<strong>电源</strong>等（不能更换主板、主背板）。</li><li><strong>磁盘性能</strong>表现在<strong>储存容量</strong>和 <strong>I/O 速度</strong>。</li><li><strong>集群技术</strong>中，如果一台主机出现故障，不会影响正常服务，但会影响系统性能。</li><li>服务器<strong>总体性能</strong>取决于 <strong>CPU 数量、CPU 主频、系统内存、网络速度</strong>(只写 CPU 数量错)</li></ul><h2 id="BGP-协议"><a href="#BGP-协议" class="headerlink" title="BGP 协议"></a>BGP 协议</h2><ul><li>BGP 采用<strong>路由向量协议</strong>，而RIP采用距离向量协议</li><li>BGP 交换路由信息的节点数不小于自治系统数。</li><li>BGP 不同自治系统(AS)的路由器之间使用的协议</li><li>一个 BGP 发言人使用 <strong>TCP（不是 UDP）</strong>与其他自治系统的 BGP发言人交换路由信息。</li><li>BGP 发言人通过 <strong>update</strong> 而不是 noticfication 分组通知相邻系统，使用 update 分组更新路由时，一个报文只能增加一条路由。</li></ul><h2 id="OSPF-协议"><a href="#OSPF-协议" class="headerlink" title="OSPF 协议"></a>OSPF 协议</h2><ul><li>OSPF 通过<strong>划分区域</strong>来提高路由更新收敛速度</li><li>每一个区域都是有一个32位的区域标识符</li><li>区域内路由器不超过 200 个</li><li>一个 OSPF 区域内每个路由器的链路状态数据库包含着<strong>本区域(不是全网)</strong>的拓扑结构信息，不知道其他区域的网络拓扑。</li><li>当链路状态发生变化时用<strong>洪泛法</strong>向所有(不是相邻)路由器发送此信息。</li></ul><h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><ul><li>工作在<strong>物理层</strong>，连接到一个集线器的所有结点共享/属于（不是独立）一个冲突域</li><li>每次只有一个结点能够发送数据，而其他的结点都处于接收数据的状态（<strong>多个节点可以同时接受数据帧</strong>）。连接到集线器的节点发送数据时，该节点将执行 <strong>CSMA/CD（不是 CA）</strong>介质访问控制方法。</li><li>采用 RISC 结构处理器的服务器通常使用 UNIX 系统(不是Windows、Android)。</li><li>RAID 技术可以提磁盘存储容量但是不能提高容错能力</li><li>在网络链路中串接一个集线器可以监听该链路中的数据包。</li></ul><h2 id="布线"><a href="#布线" class="headerlink" title="布线"></a>布线</h2><ul><li>双绞线可以<strong>避免电磁干扰</strong>。</li><li>嵌入式插座用来连接双绞线。（不是连接楼层配线架）</li><li>多介质插座用来连接<strong>铜缆</strong>和<strong>光纤</strong>（写其他的错），满足用户“光纤到桌面”的需求。</li><li>建筑群子系统可以是多种布线方式的任意组合（“一般用双绞线连接”错）。 </li><li>STP比UTP 成本高、复杂，但抗干扰能力强、辐射小</li><li>对于高速率终端可采用光纤直接到桌面的方案</li><li>管理子系统设置在楼层配线间内，提供与其他子系统连接的手段。</li></ul><h2 id="IEEE"><a href="#IEEE" class="headerlink" title="IEEE"></a>IEEE</h2><ul><li>IEEE 802.11 的三个物理层定义包括了<strong>两个扩频技术（FHSS、DSSS）</strong>和<strong>一个红外传播规范</strong>。</li><li>802.11 无线传输频道定义在 2.4GHz ISM 频段，<strong>定义的传输速率是</strong> 1Mbps 和 2Mbps。</li><li>IEEE802.11 在 MAC 子层引入了一个 <strong>RTS/CTS</strong> 选项。</li><li>IEEE802.11 运行在 2.4GHz ISM 频段，最大传输速率是1~2Mbps</li><li>IEEE802.11b 运行在 2.4GHz ISM 频段，最大传输速率是11Mbps，最大容量是 33Mbps</li><li>IEEE 802.1d 是当前最流行的 <strong>STP（生成树协议）标准</strong>。</li><li>点对点模式是指<strong>无线网卡和无线网卡</strong>之间的通信方式。它最多可以允许 <strong>256</strong> 台 PC 连接。</li><li>无线接入点 AP 的作用是提供无线和有线网络之间的桥接，而非无线结点。</li></ul><h2 id="www-服务器"><a href="#www-服务器" class="headerlink" title="www 服务器"></a>www 服务器</h2><ul><li>建立 Web 站点时必须为该站点指定一个<strong>主目录</strong>（不一定在本地计算机/服务器），也可以是<strong>虚拟的子目录</strong>。</li><li>设置了默认页面，访问时才会直接(自动)打开 default.html</li><li><strong>带宽限制选项</strong>限制该网站的可使用带宽；<strong>网站连接选项</strong>可设置客户端 Web 连接数量</li></ul><h2 id="FTP-服务器"><a href="#FTP-服务器" class="headerlink" title="FTP 服务器"></a>FTP 服务器</h2><ul><li>初始状态下没有设置管理员密码，可以直接进入 Serv-U 管理程序</li><li>向服务器中添加“anonymous”，系统自动判定为匿名用户。而不是创建新域时<strong>自动</strong>添加一个“anonymous”匿名。</li><li>FTP 服务器缺省端口号为 <strong>21</strong>，但是有时因为某种原因则不能使用 21 号端口，但可以选择其他合适的端口号。</li><li>服务器可构建多个由 IP 地址和端口号识别的虚拟服务器，每个虚拟服务器（域）<strong>由 IP 地址和端口号唯一识别</strong>，<strong>而不是只依靠 IP 地址。</strong></li></ul><h2 id="邮件（Winmail-邮件服务器）"><a href="#邮件（Winmail-邮件服务器）" class="headerlink" title="邮件（Winmail 邮件服务器）"></a>邮件（Winmail 邮件服务器）</h2><ul><li>Winmail 邮件服务器支持基于 <strong>Web 方式</strong>的访问和管理，因此在安装邮件服务器软件之前要安装 IIS</li><li>Winmail 邮件服务器允许用户自行注册新邮箱，需输入邮箱名、密码等信息，<strong>而域名是服务器固定的，并不能自行设置</strong>。但 Winmail 用户不可以使用 Outlook 自行注册新邮箱。</li><li>在 <strong>Winmail 快速设置向导</strong>（<strong>不是系统设置</strong>）中创建新用户时，输入新建用户的信息，包括用户名、域名及用户密码（不是系统邮箱的密码、管理员密码），可选择是否允许客户通过Winmail 注册新邮箱</li></ul><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><ul><li><p>SYN Flooding 攻击：使用无效的 IP 地址，利用 TCP 连接的三次握手过程，使得受害主机处于开放会话的请求之中，直至连接超时。在此期间，受害主机将会连续接受这种会话请求,最终因耗尽资源而停止响应。</p></li><li><p>DDos 攻击：利用攻破的多个系统发送大量请求去集中攻击其他目标，受害设备因为无法处理而拒绝服务。</p></li><li><p>SQL 注入攻击：属于利用系统漏洞，基于网络的入侵防护系统和基于主机入侵防护系统都难以阻断。<strong>防火墙（基于网络的防护系统）无法阻断这种攻击。</strong></p></li><li><p>Land 攻击：向某个设备发送数据包，并将数据包的源 IP 地址和目的地址都设置成攻击目标的地址。</p></li><li><p>协议欺骗攻击：通过伪造某台主机的 IP 地址窃取特权的攻击。有以下几种：（1）IP 欺骗攻击。（2）ARP 欺骗攻击。（3）DNS 欺骗攻击。（4）源路由欺骗攻击。</p></li><li><p>DNS 欺骗攻击：攻击者采用某种欺骗手段，使用户查询服务器进行域名解析时获得一个错误的 IP 地址，从而可将用户引导到错误的 Internet 站点。</p></li><li><p>IP 欺骗攻击：通过伪造某台主机的 IP 地址骗取特权，进而进行攻击的技术。</p></li><li><p>Cookie 篡改攻击：通过对 Cookie 的篡改可以实现非法访问目标站点，基于网络的入侵防护系统无法阻断。</p></li><li><p>Smurf 攻击：攻击者冒充受害主机的 IP 地址，向一个大的网络发送 echo request 的定向广播包，此网络的许多主机都做出回应，受害主机会收到大龄的 echo reply 消息。基于网络的入侵防护系统可以阻断 Smurf 攻击。</p></li><li><p>基于网络的防护系统无法阻断 <strong>Cookie 篡改</strong>、<strong>DNS 欺骗</strong>、<strong>SQL注入</strong>。</p></li><li><p>基于网络的入侵防护系统和基于主机入侵防护系统都难以阻断的是跨站脚本攻击、SQL 注入攻击。 </p></li></ul><h2 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><ul><li>VLAN 以交换式网络为基础。</li><li>VLAN 工作在 OSI 参考模型的第二层(数据链路层)，而不是网络层。VLAN 之间通信必须通过路由器。</li></ul><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><ul><li>工作频段在 2.402GHz~2.480GHz 的ISM 频段。</li><li>同步信道速率 64kbps。</li><li>标称数据速率是 1Mbps。</li><li>非对称的异步信道速率为 723.2kbps/57.6kbps，对称的异步信道速率为 433.9kbps（全双工）。</li></ul><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><ul><li>高性能路由器一般采用采用可交换式的结构，传统的核心路 由器采用共字背板的结构。</li><li>丢包率是衡量路由器超负荷工作时的性能指标之一。(“路由表容量”不是) </li><li>吞吐量是指路由器的包转发能力，包括端口吞吐量与整机吞吐量。背板能力决定路由器吞吐量。（不是吞吐量决定了路由器的背板能力） </li></ul><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><ul><li><p>无源光纤网FPON，按照ITU标准可分为两部分:(1) <strong>OC-3，155.520 Mbps</strong> 的对称业务。(2) <strong>上行OC-3，155.520 Mbps</strong>，下行<strong>0C-12, 622.080 Mbps</strong>的不对称业务。</p></li><li><p>全双工端口的带宽计算方法：<strong>端口数x端口速率x2</strong>.</p></li><li><p><strong>ipconfig</strong>显示当前TCP/ITP网络配置，<strong>netstat</strong>显示本机与远程计算机的基于TCP/IP的NeTBIOS的统计及连接信息，<strong>pathping</strong>将报文发送到所经过地所有路由器，并根据每一跳返回的报文进行统计;<strong>route</strong>显示或修改本地IP路由表条目。</p></li><li><p>三种备份的比较：</p><p>| 比较     |          | 有大到小， 由快到慢 |          |<br>| ———— | ———— | :————————-: | ———— |<br>| 空间使用 | 完全备份 |      差异备份       | 增量备份 |<br>| 备份速度 | 增量备份 |      差异备份       | 完全备份 |<br>| 恢复速度 | 完全备份 |      差异备份       | 增量备份 |</p></li><li><p>Cisco PIX 525防火墙：</p><ul><li>特权模式：PIX防火墙开机自检后，即处于此种模式。</li><li>非特权模式：</li><li>监视模式：可以进行操作系统映像更新和口令恢复</li><li>配置模式：</li></ul></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/56552345">计算机三级网络技术笔记（精华版）写文章</a> </p>]]></content>
      
      
      <categories>
          
          <category> 计算机三级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建个人博客</title>
      <link href="2021/02/26/Blog/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>2021/02/26/Blog/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>我是在<strong>Ubuntu 20.04</strong> 下面搭建的博客，所以下面记录操作的命令都是针对于Ubuntu下面的命令。对于Windows下面的搭建，现在暂时还没有尝试，以后遇到了再更新操作。特别说明该个人博客是基于<strong>hexo</strong>框架搭建的，服务端是交于<strong>github</strong>管理的。</p><span id="more"></span><h2 id="安装nodejs-npm"><a href="#安装nodejs-npm" class="headerlink" title="安装nodejs, npm"></a>安装nodejs, npm</h2><p>因为hexo框架是依赖于nodejs，所以我们需要先安装好<strong>nodejs</strong>和包管理器<strong>nmp</strong>。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nodejs npm</span><br></pre></td></tr></tbody></table></figure><p>查看是否安装成功：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node --version</span><br><span class="line">npm --version</span><br></pre></td></tr></tbody></table></figure><p>正常输出就安装成功了。</p><h2 id="安装cnmp"><a href="#安装cnmp" class="headerlink" title="安装cnmp"></a>安装cnmp</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></tbody></table></figure><p>这里要加入源，我用的是taobao源。检查一下安装：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></tbody></table></figure><h2 id="安装hexo框架"><a href="#安装hexo框架" class="headerlink" title="安装hexo框架"></a>安装hexo框架</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cnpm install -g hexo-cli</span><br></pre></td></tr></tbody></table></figure><p>检查一下安装：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></tbody></table></figure><h2 id="创建博客目录并初始化"><a href="#创建博客目录并初始化" class="headerlink" title="创建博客目录并初始化"></a>创建博客目录并初始化</h2><p>我在家目录下面创建了一个<code>~/PersonalBlog/</code>，命令如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir PersonalBlog &amp;&amp; cd PersonalBlog</span><br></pre></td></tr></tbody></table></figure><p><strong>hexo</strong>初始化：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm audix fix</span><br></pre></td></tr></tbody></table></figure><p>本地运行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure><p>点击 <a href="http://localhost:4000">http://localhost:4000</a> ，博客页面在本地就有了。</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325111017.png" alt="image-20210225150228015"></p><h2 id="创建第一篇博客"><a href="#创建第一篇博客" class="headerlink" title="创建第一篇博客"></a>创建第一篇博客</h2><p>创建第一篇博客：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n "My First Blog"</span><br></pre></td></tr></tbody></table></figure><p>然后vim向 <code>~/PersonalBlog/source/_posts/My-First-Blog.md</code> 随便写入：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325111603.png" alt="image-20210325111602924"></p><p><code>:wq</code>退出</p><p>然后：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure><p>看看效果：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325111730.png" alt="image-20210325111730245"></p><h2 id="github服务端部署"><a href="#github服务端部署" class="headerlink" title="github服务端部署"></a>github服务端部署</h2><p>在github账户下创建一个仓库，仓库名必须是：<strong>xxx.github.io</strong>，所以我的就是<code>miller-em.github.io</code>，欢迎访问，哈哈哈。</p><p>安装hexo-deployer-git:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></tbody></table></figure><p>修改博客根目录下的<code>_config.yml</code>：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></tbody></table></figure><p>最后这里修改一下：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325111808.png" alt="image-20210325111807897"></p><p>保存退出后，推向github服务器：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></tbody></table></figure><p>输入你的github用户名和密码，成功后在浏览器输入：xxx.github.io，看看效果：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325111838.png" alt="image-20210325111838715"></p><p>到这里，你的个人博客搭建就完成了！</p><h2 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h2><p>我觉得原始主题不太符合我的style，所以我就换了一个主题。我用的是nexT主题，黑白配色简约淡雅。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></tbody></table></figure><p>修改<code>_config.yml</code>，将主题改为next：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325111948.png" alt="image-20210325111948090"></p><h2 id="配置NexT"><a href="#配置NexT" class="headerlink" title="配置NexT"></a>配置NexT</h2><ol><li><p>设置博客根目录下_config.yml：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325112005.png" alt="image-20210325112005322"></p></li><li><p>设置菜单栏：</p><p><img src="https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210325112020.png" alt="image-20210325112020464"></p><p>在<code>themes/next/_config.yml</code>下面的查看menu.</p><p>在根目录下面，输入以下代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new page "about" </span><br><span class="line">hexo new page "tags"</span><br><span class="line">hexo new page "categories"</span><br><span class="line">hexo new page "archives"</span><br><span class="line">hexo new page "search"</span><br></pre></td></tr></tbody></table></figure><p>此时在根目录的sources文件夹下会生成categories、tags、about、archives、search四个文件，每个文件中有一个<code>index.md</code>文件：</p></li><li><p>设置建站时间</p><p>打开主题配置文件即themes/next下的_config.yml，查找since：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup. If not defined, current year will be used.</span><br><span class="line">  since: 2021-02</span><br></pre></td></tr></tbody></table></figure></li><li><p>设置头像</p><p>打开主题配置文件即themes/next下的_config.yml，查找avatar，url后是图片的链接地址：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: /images/avatar.gif</span><br><span class="line">  # If true, the avatar will be dispalyed in circle.</span><br><span class="line">  rounded: true</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: tru</span><br></pre></td></tr></tbody></table></figure></li><li><p>网站图标设置</p><p>我是在这个网站找的图标，免费的图标素材网站：<a href="https://link.zhihu.com/?target=https%3A//www.easyicon.net/1220579-maple_leaf_icon.html">Easyicon</a></p><p>下载16x16和32x32的图标后，打开主题配置文件，查找favicon，只要修改small和medium为你的图标路径：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16-next.png</span><br><span class="line">  medium: /images/favicon-32x32-next.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /images/manifest.json</span><br><span class="line">  #ms_browserconfig: /images/browserconfig.xml</span><br></pre></td></tr></tbody></table></figure></li><li><p>设置博文内链接为蓝色</p><p>打开themes/next/source/css/_common/components/post/post.styl文件，将下面的代码复制到文件最后：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.post-body p a{</span><br><span class="line">     color: #0593d3;</span><br><span class="line">     border-bottom: none;</span><br><span class="line">     &amp;:hover {</span><br><span class="line">       color: #0477ab;</span><br><span class="line">       text-decoration: underline;</span><br><span class="line">     }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></li><li><p>显示文章字数和阅读时长</p><p>从根目录Blog打开Git Bash，执行下面的命令，安装插件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></tbody></table></figure><p>然后打开<strong>站点配置文件，</strong>在文件末尾加上下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true                # 文章字数统计</span><br><span class="line">  time: true                   # 文章阅读时长</span><br><span class="line">  total_symbols: true          # 站点总字数统计</span><br><span class="line">  total_time: true             # 站点总阅读时长</span><br><span class="line">  exclude_codeblock: false     # 排除代码字数统计</span><br></pre></td></tr></tbody></table></figure></li><li><p>添加Fork me on Github</p><p>选择你喜欢的类型，打开<a href="https://link.zhihu.com/?target=http%3A//tholman.com/github-corners/">小猫</a>或者<a href="https://link.zhihu.com/?target=https%3A//github.blog/2008-12-19-github-ribbons/">字</a>，复制代码添加到themes/next/layout/_layout.swig文件中，放在</p><div class="headband"></div>后面：<p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="headband"&gt;&lt;/div&gt;</span><br><span class="line">    &lt;a href="https://github.com/Miller_em" class="github-corner" ....</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>www.codesheep.com</p><p><a href="https://zhuanlan.zhihu.com/p/106060640">个人博客第8篇——优化主题（持续更新）</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Pytorch训练一个图像分类器</title>
      <link href="2021/02/26/deep_learning/%E5%88%A9%E7%94%A8pytorch%E8%AE%AD%E7%BB%83%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E5%99%A8/"/>
      <url>2021/02/26/deep_learning/%E5%88%A9%E7%94%A8pytorch%E8%AE%AD%E7%BB%83%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>学习一个框架最快的方式就是，自己利用框架针对某个案例自己敲一遍。而作为一个AI视觉者，入门的案例肯定是图像分类，所以，我选择了pytorch官网里的tutorials的一个例子。对于深度学习来说，肯定要经过下面几个步骤：<strong>数据处理（类型转换，归一化）</strong>， <strong>搭建网络结构</strong>，<strong>训练</strong>，<strong>测试</strong>，<strong>导出/加载模型</strong>。下面我将会用这个例子实践以上方面，加深对Pytorch基本语法的掌握。</p> <span id="more"></span><h2 id="关于数据"><a href="#关于数据" class="headerlink" title="关于数据"></a>关于数据</h2><p>一般来说，当你用pytorch来做深度学习有关的事情的时候，比如说处理图像，音频，文本和视频，你都是需要用一些python的包来将numpy类型的数据转化为<code>torch *Tensor</code></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
            <tag> python </tag>
            
            <tag> classfication </tag>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
