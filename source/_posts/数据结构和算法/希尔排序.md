---
title: 希尔排序
date: 
tags: ['排序']
categories: 数据结构和算法
top: false
---

今天刷到了洛谷的排序算法的部分的题目，是这样的：

![image-20210712185219120](https://cdn.jsdelivr.net/gh/Miller-em/IMAGS/img/20210712185226.png)

很明显对于输入来说，m <= 2000000这就表明我们必须舍弃O(n^2)的排序算法，也就是冒泡，选择，插入。这几个很简单容易理解，我不打算通过这道题来复习了。这道题我打算采用的是**希尔排序**。

 <!-- more -->

## 希尔排序算法介绍

**希尔排序**，也称**递减增量排序算法**，是**插入排序** 的一种更高效的改进版本。希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

1. 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到 **线性排序** 的效率；
2. 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。

步长的选择是希尔排序的重要部分。

只要最终步长为1任何步长序列都可以工作。

算法最开始以一定的步长进行排序。

然后会继续以一定步长进行排序，最终算法以步长为1进行排序。

当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。

希尔排序的算法步骤如下：

1. 分组：定义一个用来分割的步长；
2. 按步长的长度K，对数组进行K趟排序；
3. 不断重复上述步骤。

## C++实现

```c++
void shell_Sort(vector<int> &a){
    int len = a.size();
    for (int i=len/2; i>1; i/=2){   //确定步长
        for (int j = 0; j < i; j++){
            for (int k = j+i, temp, preIndex; k < len; k+=i){
                temp = a[k];		//存放后一个元素(哨兵)
                preIndex = k - i;	//前一个元素的下标
                while(preIndex >= 0 && a[preIndex]>temp){
                    a[preIndex+i] = a[preIndex];
                    preIndex -= i;
                }
                a[preIndex+i] = temp;
            }
        }
    }
}
```

